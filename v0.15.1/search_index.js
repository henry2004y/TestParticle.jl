var documenterSearchIndex = {"docs":
[{"location":"examples/basics/demo_array/#demo_array","page":"Array Shape Conversion","title":"Array Shape Conversion","text":"(Image: Author) (Image: Update time)\n\nThis example shows how to convert between row-major arrays in Python/C and column-major arrays in Julia/Fortran. Let's say you have created an 4D array in Numpy of size (nx, ny, nz, 3):\n\nimport numpy as np\n\nnx, ny, nz = 2, 4, 6\n# Calculate the total number of elements\ntotal_elements = nx * ny * nz * 3\n\n# Create a 1D array with the desired range\none_d_array = np.arange(1, total_elements + 1)\n\n# Reshape the 1D array into the desired 4D shape\nB = one_d_array.reshape((nx, ny, nz, 3))\n# Validation\nprint(B[0,1,2,1]) # should be 26\n\nfile_name = \"my_field.npz\"\nnp.savez(file_name, data=B)\n\nIn Julia, you can load the Numpy array and convert to a Julia-style field array that TestParticle.jl takes:\n\nusing NPZ\n\nvars = npzread(\"my_field.npz\")\nB = vars[\"data\"] # size (nx, ny, nz, 3)\nB = permutedims(B, (4,1,2,3)) # size (3, nx, ny, nz)\n# Validation\nprintln(B[2,1,2,3]) # should be 26\n\nNote that the shape of the Julia-style array is now (3, nx, ny, nz), instead of (3, nz, ny, nx). The key thing here is that the array storage ordering is an implementation detail that is not related to how we do math. When we use the NPZ package to load the Numpy array, the storage ordering has already been modified. We perform one permutation of the vector dimension to move it to the first index such that the vector components becomes continuous and adapt to the expection of TestParticle.jl.\n\n\n\nThis page was generated using DemoCards.jl.","category":"section"},{"location":"examples/basics/demo_dimensionless/#demo_dimensionless","page":"Dimensionless Units","title":"Dimensionless Units","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace charged particles in dimensionless units. After normalization, q=1 B=1 m=1 so that the gyroradius r_L = mv_perpqB = v_perp. All the quantities are given in dimensionless units: if the magnetic field is homogeneous and the initial perpendicular velocity v_perp 0^prime is 4, then the gyroradius is 4. To convert them to the original units, v_perp = v_perp^prime * U_0 and r_L = r_L^prime * l_0 = 4*l_0. Check Demo: single tracing with additional diagnostics and Demo: Dimensionless and Dimensional Tracing for explaining the unit conversion.\n\nTracing in dimensionless units is beneficial for many scenarios. For example, MHD simulations do not have intrinsic scales. Therefore, we can do dimensionless particle tracing in MHD fields, and then convert to any scale we would like.\n\nNow let's demonstrate this with trace_normalized! and trace_relativistic_normalized!.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing TestParticle: qᵢ, mᵢ\nusing CairoMakie\n\n# Number of cells for the field along each dimension\nnx, ny, nz = 4, 6, 8\n# Unit conversion factors between SI and dimensionless units\nB₀ = 10e-9            # [T]\nΩ = abs(qᵢ) * B₀ / mᵢ # [1/s]\nt₀ = 1 / Ω            # [s]\nU₀ = 1.0              # [m/s]\nl₀ = U₀ * t₀          # [m]\nE₀ = U₀*B₀            # [V/m]\n# All quantities are in dimensionless units\nx = range(-10, 10, length = nx) # [l₀]\ny = range(-10, 10, length = ny) # [l₀]\nz = range(-10, 10, length = nz) # [l₀]\n\nB = fill(0.0, 3, nx, ny, nz) # [B₀]\nB[3, :, :, :] .= 1.0\nE = fill(0.0, 3, nx, ny, nz) # [E₀]\n\nparam = prepare(x, y, z, E, B; species = User)\n\n# Initial condition\nstateinit = let\n   x0 = [0.0, 0.0, 0.0] # initial position [l₀]\n   u0 = [4.0, 0.0, 0.0] # initial velocity [v₀]\n   [x0..., u0...]\nend\n# Time span\ntspan = (0.0, π) # half gyroperiod\n\nprob = ODEProblem(trace_normalized!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\n### Visualization\nf = Figure(fontsize = 18)\nax = Axis(f[1, 1],\n   title = \"Proton trajectory\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   limits = (-4.1, 4.1, -8.1, 0.1),\n   aspect = DataAspect()\n)\n\nlines!(ax, sol, idxs = (1, 2))\n\n\n(Image: )\n\nIn the relativistic case,\n\nVelocity is normalized by speed of light c, V = V^prime c;\nMagnetic field is normalized by the characteristic magnetic field, B = B^prime B_0;\nElectric field is normalized by E_0 = cB_0, E = E^prime E_0;\nLocation is normalized by the L = c  Omega_0, where Omega_0 = qB_0  m, and\nTime is normalized by Omega_0^-1, t = t^prime * Omega_0^-1.\n\nIn the small velocity scenario, it should behave similar to the non-relativistic case:\n\nparam = prepare(xu -> SA[0.0, 0.0, 0.0], xu -> SA[0.0, 0.0, 1.0]; species = User)\ntspan = (0.0, π) # half period\nstateinit = [0.0, 0.0, 0.0, 0.01, 0.0, 0.0]\nprob = ODEProblem(trace_relativistic_normalized!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\n### Visualization\nf = Figure(fontsize = 18)\nax = Axis(f[1, 1],\n   title = \"Relativistic particle trajectory\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   #limits = (-0.6, 0.6, -1.1, 0.1),\n   aspect = DataAspect()\n)\n\nlines!(ax, sol, idxs = (1, 2))\n\n\n(Image: )\n\nIn the large velocity scenario, relativistic effect takes place:\n\nparam = prepare(xu -> SA[0.0, 0.0, 0.0], xu -> SA[0.0, 0.0, 1.0]; species = User)\ntspan = (0.0, π) # half period\nstateinit = [0.0, 0.0, 0.0, 0.9, 0.0, 0.0]\nprob = ODEProblem(trace_relativistic_normalized!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\n### Visualization\nf = Figure(fontsize = 18)\nax = Axis(f[1, 1],\n   title = \"Relativistic particle trajectory\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   aspect = DataAspect()\n)\n\nlines!(ax, sol, idxs = (1, 2))\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_currentsheet/#demo_currentsheet","page":"Current sheet","title":"Current sheet","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace protons in a stationary magnetic field that corresponds to the 1D Harris current sheet defined by a reference strength and width. A Wiki reference can be found here.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nimport TestParticle as TP\nusing TestParticle: Rₑ\nusing LinearAlgebra: norm\nusing CairoMakie\n\n### Obtain field\n\n# Harris current sheet parameters in SI units. Bn is the z-component.\nconst B₀, Bn, L = 20e-9, 2e-9, 0.4Rₑ\n\ngetB(xu) = SVector{3}(TP.getB_CS_harris(xu[1:3], B₀, L, Bn))\n\ngetE(xu) = SA[0.0, 0.0, 0.0]\n\n### Initialize particles\n\n# Initial condition\nstateinit = let\n   # initial particle energy, [eV]\n   Ek = 8e3\n   # initial velocity, [m/s]\n   vmag = TP.c*√(1-1/(1+Ek*TP.qᵢ/(TP.mᵢ*TP.c^2))^2)\n   θ = -60\n   ϕ = 30\n   v₀ = [vmag*cosd(θ), vmag*sind(θ)*sind(ϕ), vmag*sind(θ)*cosd(ϕ)]\n   # initial position, [m]\n   r₀ = [1Rₑ, 0Rₑ, 1Rₑ]\n\n   [r₀..., v₀...]\nend\n\nparam = prepare(getE, getB)\ntspan = (0.0, -400.0)\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\n\nsol = solve(prob, Vern9())\n\n### Visualization\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Particle trajectory near the Harris current sheet\",\n   xlabel = \"x [Re]\",\n   ylabel = \"y [Re]\",\n   zlabel = \"z [Re]\",\n   aspect = :data\n)\n\nn = 2000 # number of timepoints\nts = range(tspan..., length = n)\nx = sol(ts, idxs = 1) ./ Rₑ |> Vector\ny = sol(ts, idxs = 2) ./ Rₑ |> Vector\nz = sol(ts, idxs = 3) ./ Rₑ |> Vector\n\nl = lines!(ax, x, y, z, label = \"50 MeV proton, B0 = 20 nT\")\naxislegend()\n\nfunction plot_B!(ax)\n   xrange = range(-5, 3, length = 5)\n   yrange = range(-1, 1, length = 5)\n   zrange = range(-2, 2, length = 5)\n\n   ps = [Point3f(x, y, z) for x in xrange for y in yrange for z in zrange]\n   B = map(p -> Vec3f(getB(p .* Rₑ) ./ B₀), ps)\n   Bmag = norm.(B)\n\n   arrows!(ax, ps, B, fxaa = true, color = Bmag, lengthscale = 0.4, arrowsize = 0.05)\nend\n\nplot_B!(ax)\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_fermi_foreshock/#demo_electron_acceleration_foreshock_transient","page":"Electron Fermi Acceleration Inside Foreshock Transient Cores","title":"Electron Fermi Acceleration Inside Foreshock Transient Cores","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example demonstrates electron acceleration via Fermi acceleration using a simple 1D model. It follows the setup described in Fermi acceleration of electrons inside foreshock transient cores. The simulation domain is 2R_E in x, where the initial magnetosheath locates at x in 0 05 R_E with a magnetic field B_z = 20mathrmnT and the bow shock at x = 05R_E. The foreshock transient boundary is at x = 15R_E initially and moves toward the bow shock at a speed U=100mathrmkms. The region beyond x=15R_E is the foreshock transient sheath in which the magnetic field is B_z=10mathrmnT. A convection electric field E_y = -1mathrmmVm, consistent with the velocity U, is introduced in the foreshock transient sheath. Between the two boundaries, 05R_E  x  15R_E, is the foreshock transient's core region.\n\nIn the first case, the magnetic field in the core region is set to zero. In the second case, a magnetic fluctuation is imposed:\n\nbeginaligned\ndelta B_xyz = sum_N = N_0^N_1 delta B_N cosleft( frac2pi N xL_0 + phi_xyz^N right) \ndelta B_N = tildeB (NN_0)^-12quad N = N_0 N_0 + 1  N_1\nendaligned\n\nHere L_0 = 1R_E is the initial length of the core in the x direction. We choose N_0 = 100 N_1 = 1000 tildeB=02mathrmnT, and phi_xyz^N as the random phases of various modes between 0 and 2π (independently different in the x, y, and z directions). As the low-frequency wave speed (sim mathcalO(10)mathrmkms) is much smaller than the electron speed (sim mathcalO(10^3)mathrmkms), we do not include wave propagation in this 1D model.\n\nOne important note about Fermi acceleration for space plasmas is that space plasmas are collisionless. Electric field is the only way to accelerate charged particles, instead of elastic collisions.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nimport TestParticle as TP\nusing TestParticle: mₑ, Rₑ, qₑ\nusing TestParticle: get_EField, get_BField\nusing Random\nusing FHist\nusing CairoMakie, Printf\n\n# For reproducible results\nRandom.seed!(1234)\n\n# Analytic EM fields\n\nfunction Bcase1(xu, t)\n   Bz = if xu[1] < 0.5Rₑ\n      20e-9\n   elseif xu[1] > 1.5Rₑ + U*t\n      10e-9\n   else\n      0.0\n   end\n\n   SA[0.0, 0.0, Bz]\nend\n\nfunction E(xu, t)\n   Ey = if xu[1] > 1.5Rₑ + U*t\n      -1e-3\n   else\n      0.0\n   end\n\n   SA[0.0, Ey, 0.0]\nend\n\nBcase2(xu, t) =\n   if xu[1] < 0.5Rₑ\n      SA[0.0, 0.0, 20e-9]\n   elseif xu[1] > 1.5Rₑ + U*t\n      SA[0.0, 0.0, 10e-9]\n   else\n      δBfunc(xu)\n   end\n\nfunction get_B_perturb(x)\n   L₀, N₀, N₁, B̃ = 1Rₑ, 100, 1000, 0.2e-9\n   B = fill(0.0, 3, length(x)) # [T]\n   # Eqs (4-5) from the paper\n   for N in N₀:N₁\n      δBn = B̃ * (N / N₀)^-1.2\n      ϕx, ϕy, ϕz = rand(SVector{3, Float64}) .* 2\n      for i in axes(B, 2)\n         δBx = δBn * cospi(2 * N * x[i] / L₀ + ϕx)\n         δBy = δBn * cospi(2 * N * x[i] / L₀ + ϕy)\n         δBz = δBn * cospi(2 * N * x[i] / L₀ + ϕz)\n         B[1, i] += δBx\n         B[2, i] += δBy\n         B[3, i] += δBz\n      end\n   end\n\n   B\nend\n\nisoutofdomain(xv, p, t) =\n   if xv[1] < 0 || xv[1] > 2Rₑ\n      return true\n   else\n      return false\n   end\n\nfunction prob_func(prob, i, repeat)\n   x0 = SA[(0.5 + rand()) * Rₑ, 0.0, 0.0] # launched in the core region\n   u0 = SA[0.0, 0.0, 0.0]\n   T₀ = 10 # [eV]\n   vth = √(2T₀*abs(qₑ)/mₑ) # [m/s]\n   vdf = Maxwellian(u0, vth)\n   v0 = TP.sample(vdf)\n\n   prob = remake(prob, u0 = [x0..., v0...])\nend\n\n\"\"\"\nKinetic energy.\n\"\"\"\nget_kinetic_energy(dx, dy, dz) = 1 // 2 * (dx^2 + dy^2 + dz^2)\n\nfunction plot_multiple(sol)\n   energy = map(x -> get_kinetic_energy(x[4:6]...), sol.u) .* mₑ ./ abs(qₑ)\n   # Obtain the EM fields along the particle trajectory\n   # [mV/m]\n   Efield = get_EField(sol)\n   Bfield = get_BField(sol)\n   E = [Efield(sol[:, istep], sol.t[istep]) .* 1e3 for istep in eachindex(sol)]\n   # [nT]\n   B = [Bfield(sol[:, istep], sol.t[istep]) .* 1e9 for istep in eachindex(sol)]\n\n   Ex = [e[1] for e in E]\n   Ey = [e[2] for e in E]\n   Ez = [e[3] for e in E]\n   Bx = [b[1] for b in B]\n   By = [b[2] for b in B]\n   Bz = [b[3] for b in B]\n\n   t = sol.t\n   x = @views sol[1, :] ./ Rₑ\n   y = @views sol[2, :] ./ Rₑ\n   z = @views sol[3, :] ./ Rₑ\n   vx = @views sol[4, :] ./ 1e3\n   vy = @views sol[5, :] ./ 1e3\n   vz = @views sol[6, :] ./ 1e3\n\n   fig = Figure(size = (900, 600), fontsize = 20)\n\n   xlabels = (\"\", \"\", \"\", \"\", \"t [s]\")\n   ylabels = (\"KE [eV]\", \"Locations [RE]\", \"V [km/s]\", \"E [mV/m]\", \"B [nT]\")\n   limits = (\n      (nothing, (nothing, nothing)),\n      (nothing, (nothing, nothing)),\n      (nothing, (nothing, nothing)),\n      (nothing, (nothing, nothing)),\n      (nothing, (nothing, nothing)))\n\n   axs = [Axis(fig[row, col], xlabel = xlabels[row],\n             ylabel = ylabels[row], limits = limits[row])\n          for row in eachindex(xlabels), col in 1:1]\n\n   linkxaxes!(axs...)\n\n   lines!(axs[1], t, energy)\n   lines!(axs[2], t, x, label = \"x\")\n   lines!(axs[2], t, y, label = \"y\")\n   lines!(axs[2], t, z, label = \"z\")\n   lines!(axs[3], t, vx, label = \"x\")\n   lines!(axs[3], t, vy, label = \"y\")\n   lines!(axs[3], t, vz, label = \"z\")\n   lines!(axs[4], t, Ex, label = \"x\")\n   lines!(axs[4], t, Ey, label = \"y\")\n   lines!(axs[4], t, Ez, label = \"z\")\n   lines!(axs[5], t, Bx, label = \"x\")\n   lines!(axs[5], t, By, label = \"y\")\n   lines!(axs[5], t, Bz, label = \"z\")\n\n   for ax in @view axs[2:5]\n      axislegend(ax, framevisible = false, orientation = :horizontal)\n   end\n\n   fig\nend\n\nfunction plot_dist(sols; t = 0, case = 1, slice = :xy)\n   ##TODO: Optimization\n   vx = Vector{eltype(sols[1].u[1])}(undef, 0)\n   vy = similar(vx)\n   vz = similar(vx)\n   for sol in sols\n      if (sol.t[end] ≥ t) && (1.5Rₑ - U*sol.t[end] > sol[1, end] > 0.5Rₑ)\n         v = sol(t)[4:6] ./ 1e3\n         append!(vx, v[1])\n         append!(vy, v[2])\n         append!(vz, v[3])\n      end\n   end\n\n   f = Figure(size = (700, 600), fontsize = 18)\n\n   if slice == :xy\n      vars = (vx, vy)\n      xlabel = L\"V_x [km/s]\"\n      ylabel = L\"V_y [km/s]\"\n   elseif slice == :xz\n      vars = (vx, vz)\n      xlabel = L\"V_x [km/s]\"\n      ylabel = L\"V_z [km/s]\"\n   elseif slice == :yz\n      vars = (vy, vz)\n      xlabel = L\"V_y [km/s]\"\n      ylabel = L\"V_z [km/s]\"\n   end\n   h2d = Hist2D(vars; nbins = (50, 50))\n   _,\n   _heatmap = plot(f[1, 1], h2d;\n      axis = (title = \"t = $t s, Case = $case, Particle Count = $(length(vx))\",\n         xlabel = xlabel, ylabel = ylabel, aspect = 1, limits = (-1e4, 1e4, -1e4, 1e4)))\n\n   Colorbar(f[1, 2], _heatmap)\n\n   f\nend\n\nfunction find_max_acceleration_index(sols; countall = true, tend = 40)\n   if countall\n      ratio = [get_kinetic_energy(sol[4:6, end]...) / get_kinetic_energy(sol[4:6, 1]...)\n               for sol in sols]\n   else\n      # only count the particles that are still trapped at t=tend\n      ratio = [get_kinetic_energy(sol[4:6, end]...) / get_kinetic_energy(sol[4:6, 1]...)\n               for sol in sols if sol.t[end] > tend-0.1]\n   end\n   imax = argmax(ratio)\n\n   energy_init = get_kinetic_energy(sols[imax][4:6, 1]...) .* mₑ ./ abs(qₑ)\n   energy_final = get_kinetic_energy(sols[imax][4:6, end]...) .* mₑ ./ abs(qₑ)\n   @printf \"Initial energy [eV]: %.2f \" energy_init\n   @printf \"Final energy [eV]: %.2f \" energy_final\n   @printf \"Kinetic energy change ratio: %.2f\\n\" ratio[imax]\n\n   imax\nend\n\nconst U = -100e3 # [m/s]\n\n# Initial condition to be overwritten in prob_func\nstateinit = zeros(6)\n# Time span [s]\ntspan = (0, 40)\n# Number of particles\ntrajectories = 1000;\n\nCase 1: 0 core field\n\nparam = prepare(E, Bcase1; species = Electron);\nprob = ODEProblem(trace!, stateinit, tspan, param)\nensemble_prob = EnsembleProblem(prob; prob_func, safetycopy = false)\n\nsols = solve(ensemble_prob, Vern9(), EnsembleThreads();\n   isoutofdomain, trajectories, verbose = true);\n\n# maximum acceleration ratio particle index\nimax = find_max_acceleration_index(sols)\n\nf = plot_multiple(sols[imax])\n\n(Image: )\n\nTrajectory of the most accelerated electron.\n\nf = plot_dist(sols, t = tspan[1], case = 1, slice = :xy)\n\n(Image: )\n\nInitial velocity distribution.\n\nf = plot_dist(sols, t = tspan[2], case = 1, slice = :xy)\n\n(Image: )\n\nFinal velocity distribution\n\nCase 2: B fluctuation core field In this case we use the native Boris pusher for demonstration. The smallest electron gyroperiod in the magnetosheath (B ∼ 20 nT) is about 2times 10^-3mathrms, and we use a time step Delta t = 2times 10^-4mathrms.\n\nconst δBfunc = let\n   x = range(0.5Rₑ, 1.5Rₑ, length = 10000)\n   δB = get_B_perturb(x)\n   TP.Field(TP.getinterp(δB, x, 1, 3))\nend\n\ndt = 2e-4 # [s]\nparam = prepare(E, Bcase2; species = Electron);\nprob = TraceProblem(stateinit, tspan, param; prob_func)\nsols = TP.solve(prob; dt, trajectories, isoutofdomain, savestepinterval = 100);\n\n# maximum acceleration ratio particle index\nimax = find_max_acceleration_index(sols)\n\nf = plot_multiple(sols[imax])\n\n(Image: )\n\nTrajectory of the most accelerated electron. Note that there are locations where we see a jump in kinetic energy with no electric field peaks; these are artifacts because we only save every 100 steps.\n\nf = plot_dist(sols, t = tspan[1], case = 2, slice = :xy)\n\n(Image: )\n\nInitial velocity distribution.\n\nf = plot_dist(sols, t = tspan[2], case = 2, slice = :xy)\n\n(Image: )\n\nFinal velocity distribution\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_savingcallback/#demo_savingcallback","page":"Single tracing with additional diagnostics","title":"Single tracing with additional diagnostics","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example demonstrates tracing one proton in an analytic E field and numerical B field. It also combines one type of normalization using a reference velocity U₀, a reference magnetic field B₀, and a reference time 1/Ω, where Ω is the gyrofrequency. This indicates that in the dimensionless units, a proton with initial perpendicular velocity 1 under magnetic field magnitude 1 will possess a gyro-radius of 1. In the dimensionless spatial coordinates, we can zoom in/out the EM field to control the number of discrete points encountered in a gyroperiod. For example, if dx=dy=dz=1, it means that a particle with perpendicular velocity 1 will \"see\" one discrete point along a certain direction oriented from the gyro-center within the gyro-radius; if dx=dy=dz=0.5, then the particle will \"see\" two discrete points. MHD models, for instance, are dimensionless by nature. There will be customized (dimensionless) units for (x,y,z,E,B) that we needs to convert the dimensionless units for computing. If we simulate a turbulence field with MHD, we want to include more discrete points within a gyro-radius for the effect of small scale perturbations to take place. (Otherwise within one gyro-period all you will see is a nice-looking helix!) However, we cannot simply shrink the spatial coordinates as we wish, otherwise we will quickly encounter the boundary of our simulation.\n\nThe SavingCallback from DiffEqCallbacks.jl can be used to save additional outputs for diagnosis. Here we save the magnetic field along the trajectory, together with the parallel velocity. Note that SavingCallback is currently not compatible with ensemble problems; for multiple particle tracing with customized outputs, see Demo: ensemble tracing with extra saving.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing TestParticle: qᵢ, mᵢ\nusing TestParticle: get_BField\nusing Statistics\nusing LinearAlgebra: normalize, ×, ⋅\nusing DiffEqCallbacks\n\nfunction getmeanB(B)\n   B₀sum = eltype(B)(0)\n   for k in axes(B, 4), j in axes(B, 3), i in axes(B, 2)\n      B₀sum += B[1, i, j, k]^2 + B[2, i, j, k]^2 + B[3, i, j, k]^2\n   end\n\n   sqrt(B₀sum / prod(size(B)[2:4]))\nend\n\n# Number of cells for the field along each dimension\nnx, ny, nz = 4, 6, 8\n# Spatial coordinates given in customized units\nx = range(-0.5, 0.5, length = nx)\ny = range(-0.5, 0.5, length = ny)\nz = range(-0.5, 0.5, length = nz)\n# Numerical magnetic field given in customized units\nB = Array{Float32, 4}(undef, 3, nx, ny, nz)\n\nB[1, :, :, :] .= 0.0\nB[2, :, :, :] .= 0.0\nB[3, :, :, :] .= 2.0\n\n# Reference values for unit conversions between the customized and dimensionless units\nconst B₀ = getmeanB(B)\nconst U₀ = 1.0\nconst l₀ = 4*nx\nconst t₀ = l₀ / U₀\nconst E₀ = U₀ * B₀\n\n### Convert from customized to default dimensionless units\n# Dimensionless spatial extents [l₀]\nx /= l₀\ny /= l₀\nz /= l₀\n# For full EM problems, the normalization of E and B should be done separately.\nB ./= B₀\nE(x) = SA[0.0 / E₀, 0.0 / E₀, 0.0 / E₀]\n\n# By default User type assumes q=1, m=1; bc=2 uses periodic boundary conditions\nparam = prepare(x, y, z, E, B; species = User, bc = 2)\n\ntspan = (0.0, π) # half averaged gyroperiod based on B₀\n\n# Dummy initial state; positions have units l₀; velocities have units U₀\nstateinit = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\nprob = ODEProblem(trace_normalized!, stateinit, tspan, param)\n\nprob.u0[4:6] = let\n   B0 = get_BField(prob)(prob.u0)\n   B0 = normalize(B0)\n\n   Bperp1 = SA[0.0, -B0[3], B0[2]] |> normalize\n   Bperp2 = B0 × Bperp1 |> normalize\n\n   # initial velocity azimuthal angle\n   ϕ = 2π*0\n   # initial velocity pitch angle w.r.t. B\n   θ = acos(0.0)\n\n   sinϕ, cosϕ = sincos(ϕ)\n   @. (B0*cos(θ) + Bperp1*(sin(θ)*cosϕ) + Bperp2*(sin(θ)*sinϕ)) * U₀\nend\n\nsaved_values = SavedValues(Float64, Tuple{SVector{3, Float64}, Float64})\n\nfunction save_B_mu(u, t, integrator)\n   b = get_BField(integrator.p)(u)\n   μ = @views b ⋅ u[4:6] / √(b[1]^2 + b[2]^2 + b[3]^2)\n\n   b, μ\nend\n\ncb = SavingCallback(save_B_mu, saved_values)\n\nsol = solve(prob, Vern9(); callback = cb);\n\nThe extra values are saved in saved_values:\n\nsaved_values\n\nSavedValues{tType=Float64, savevalType=Tuple{StaticArraysCore.SVector{3, Float64}, Float64}}\nt:\n[0.0, 0.0007064003808057418, 0.006151342839884229, 0.038201626132344534, 0.22186818812944697, 0.8136537782789145, 1.7421083088976763, 2.829424240198695, 3.141592653589793]\nsaveval:\nTuple{StaticArraysCore.SVector{3, Float64}, Float64}[([0.0, 0.0, 1.0], 6.123233995736766e-17), ([0.0, 0.0, 1.0], 6.123233995736766e-17), ([0.0, 0.0, 1.0], 6.123233995736766e-17), ([0.0, 0.0, 1.0], 6.123233995736766e-17), ([0.0, 0.0, 1.0], 6.123233995736766e-17), ([0.0, 0.0, 1.0], 6.123233995736766e-17), ([0.0, 0.0, 1.0], 6.123233995736766e-17), ([0.0, 0.0, 1.0], 6.123233995736766e-17), ([0.0, 0.0, 1.0], 6.123233995736766e-17)]\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_spherical/#demo_spherical_B","page":"Tracing in spherical coordinates","title":"Tracing in spherical coordinates","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example demonstrates a single proton motion under a uniform B field defined in spherical coordinates following the same values in Demo: Helix motion. The E field is set to zero.\n\nimport TestParticle as TP\nusing OrdinaryDiffEq, StaticArrays\nusing CairoMakie\n\n# Define the magnetic field in spherical coordinates\nr = logrange(0.1, 10.0, length = 4)\nθ = range(0, π, length = 8)\nϕ = range(0, 2π, length = 8)\n\nB₀ = 1e-8 # [nT]\nB = zeros(3, length(r), length(θ), length(ϕ))\n\nfor (iθ, θ_val) in enumerate(θ)\n   sinθ, cosθ = sincos(θ_val)\n   B[1, :, iθ, :] .= B₀ * cosθ\n   B[2, :, iθ, :] .= -B₀ * sinθ\nend\n\nIn TestParticle.jl v0.15, we introduced two new grid geometries: Spherical() and SphericalNonUniformR(). Spherical() assumes uniform range (r,θ,ϕ) coordinates, whereas SphericalNonUniformR() accepts non-uniform coordinates.\n\nzero_E = TP.ZeroField()\n\n# Initial condition\nstateinit = let x0 = [1.0, 0.0, 0.0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 18)\n\nparam = TP.prepare(\n   r, θ, ϕ, zero_E, B; species = TP.Proton, gridtype = TP.SphericalNonUniformR())\nprob = ODEProblem(TP.trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\n# Visualization\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Helix Trajectory in Spherical B-field\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\n\nplot!(ax, sol, idxs = (1, 2, 3))\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_polarization_drift/#demo_polarization_drift","page":"Polarization drift","title":"Polarization drift","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates a single proton motion under time-varying E field. More theoretical details can be found in Time-Varying E Drift, and Fundamentals of Plasma Physics by Paul Bellan.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing CairoMakie\n\nuniform_B(x) = SA[0, 0, 1e-8]\n\nfunction time_varying_E(x, t)\n   # return SA[0, 1e-9*cos(0.1*t), 0]\n   return SA[0, 1e-9 * 0.1 * t, 0]\nend\n\n# Initial condition\nstateinit = let x0 = [1.0, 0, 0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 100)\nparam = prepare(time_varying_E, uniform_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n# Functions for obtaining the guiding center from actual trajectory\ngc = param |> get_gc_func\nv_perp(xu) = sqrt(xu[4]^2 + xu[5]^2)\n\n# Visualization\nf = Figure(size = (800, 600), fontsize = 18)\nax1 = Axis3(f[1:3, 1],\n   title = \"Polarization Drift\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data,\n   azimuth = 0.9π,\n   elevation = 0.1π\n)\nax2 = Axis(f[1, 2], xlabel = \"time [s]\", ylabel = \"v_perp [m/s]\")\nax3 = Axis(f[2, 2], xlabel = \"time [s]\", ylabel = \"y [m]\")\nax4 = Axis(f[3, 2], xlabel = \"time [s]\", ylabel = \"gc_y [m]\")\n\ngc_y(t, x, y, z, vx, vy, vz) = (t, gc(SA[x, y, z, vx, vy, vz])[2])\nv_perp(t, vy, vz) = (t, sqrt(vy^2 + vz^2))\n\nlines!(ax1, sol, idxs = (1, 2, 3))\nlines!(ax2, sol, idxs = (v_perp, 0, 5, 6))\nlines!(ax3, sol, idxs = 2)\nlines!(ax4, sol, idxs = (gc_y, 0, 1, 2, 3, 4, 5, 6))\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_gradient_B/#demo_gradB","page":"Grad-B drift","title":"Grad-B drift","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates a single proton motion under a non-uniform B field with gradient ∇B ⊥ B. The orbit of guiding center includes some high order terms, it is different from the formula of magnetic field gradient drift of some textbooks which just preserves the first order term. It is more complex than the simpler ExB drift. More theoretical details can be found in Grad-B Drift, and Fundamentals of Plasma Physics by Paul Bellan.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing LinearAlgebra: ×, ⋅, normalize, norm\nusing ForwardDiff: gradient\nusing CairoMakie\n\ngrad_B(x) = SA[0, 0, 1e-8 + 1e-9 * x[2]]\n\nuniform_E(x) = SA[1e-9, 0, 0]\n\nabs_B(x) = norm(grad_B(x))\n\n# Trace the orbit of the guiding center using analytical drifts\nfunction trace_gc!(dx, x, p, t)\n   q2m, _, E, B, _, sol = p\n   xu = sol(t)\n   gradient_B = gradient(abs_B, x)\n   Bv = B(x)\n   b = normalize(Bv)\n   v_par = (xu[4:6] ⋅ b) .* b\n   v_perp = xu[4:6] - v_par\n   dx[1:3] = norm(v_perp)^2*(Bv × gradient_B)/(2*q2m*norm(Bv)^3) +\n             (E(x) × Bv) / norm(Bv)^2 + v_par\nend\n\n# Initial condition\nstateinit = let x0 = [1.0, 0, 0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 20)\nparam = prepare(uniform_E, grad_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n# Functions for obtaining the guiding center from actual trajectory\ngc = param |> get_gc_func\ngc_x0 = gc(stateinit) |> Vector\nprob_gc = ODEProblem(trace_gc!, gc_x0, tspan, (param..., sol))\nsol_gc = solve(prob_gc, Vern7(); save_idxs = [1, 2, 3])\n\n# Numeric and analytic results\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Grad-B Drift\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data,\n   azimuth = 0.3π\n)\n\ngc_plot(x, y, z, vx, vy, vz) = (gc(SA[x, y, z, vx, vy, vz])...,)\n\nlines!(ax, sol, idxs = (1, 2, 3), color = Makie.wong_colors()[1])\nlines!(ax, sol, idxs = (gc_plot, 1, 2, 3, 4, 5, 6), color = Makie.wong_colors()[2])\nlines!(ax, sol_gc, idxs = (1, 2, 3), color = Makie.wong_colors()[3])\n\n\n(Image: )\n\nNote that in this grad-B drift case, the analytic and numeric guiding centers have different trajectories.\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_dimensionless_dimensional/#demo_dimensionless_dimensional","page":"Dimensionless and Dimensional Tracing","title":"Dimensionless and Dimensional Tracing","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace charged particles in both dimensional and dimensionless units. We first solve the Lorentz equation in SI units, and then convert the quantities to normalized units and solve it again in dimensionless units.\n\nThe Lorentz equation in SI units is written as\n\nfracmathrmdmathbfvmathrmdt = fracqmleft( mathbfvtimesmathbfB + mathbfE right)\n\nIt can be normalized to\n\nfracmathrmdmathbfv^primemathrmdt^prime = mathbfv^primetimesmathbfB^prime + mathbfE^prime\n\nwith the following transformation\n\nbeginaligned\nmathbfv = mathbfv^prime V_0 \nt = t^prime t_0 = t^prime Omega^-1 = t^prime fracmqB_0 \nmathbfB = mathbfB^prime B_0 \nmathbfE = mathbfE^prime E_0 = mathbfE^prime V_0 B_0\nendaligned\n\nwhere all the coefficients with subscript 0 are expressed in SI units. All the variables with a prime are written in the dimensionless units.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing TestParticle: c, qᵢ, mᵢ\nusing CairoMakie\n\n# Unit conversion factors between SI and dimensionless units\nconst B₀ = 1e-8             # [T]\nconst U₀ = c                # [m/s]\nconst E₀ = U₀*B₀            # [V/m]\nconst Ω = abs(qᵢ) * B₀ / mᵢ # [1/s]\nconst t₀ = 1 / Ω            # [s]\nconst l₀ = U₀ * t₀          # [m]\n# Electric field magnitude in SI units\nconst Emag = 1e-8           # [V/m]\n### Solving in SI units\nB(x) = SA[0, 0, B₀]\nE(x) = SA[Emag, 0.0, 0.0]\n\n# Initial conditions\nx0 = [0.0, 0.0, 0.0] # [m]\nv0 = [0.0, 0.01c, 0.0] # [m/s]\nstateinit1 = [x0..., v0...]\ntspan1 = (0, 2π*t₀) # [s]\n\nparam1 = prepare(E, B, species = Proton)\nprob1 = ODEProblem(trace!, stateinit1, tspan1, param1)\nsol1 = solve(prob1, Vern9(); reltol = 1e-4, abstol = 1e-6)\n\n### Solving in dimensionless units\nB_normalize(x) = SA[0, 0, B₀ / B₀]\nE_normalize(x) = SA[Emag / E₀, 0.0, 0.0]\n# For full EM problems, the normalization of E and B should be done separately.\nparam2 = prepare(E_normalize, B_normalize; species = User)\n# Scale initial conditions by the conversion factors\nx0 ./= l₀\nv0 ./= U₀\ntspan2 = (0, 2π)\nstateinit2 = [x0..., v0...]\n\nprob2 = ODEProblem(trace_normalized!, stateinit2, tspan2, param2)\nsol2 = solve(prob2, Vern9(); reltol = 1e-4, abstol = 1e-6)\n\n### Visualization\nf = Figure(fontsize = 18)\nax = Axis(f[1, 1],\n   xlabel = \"x [km]\",\n   ylabel = \"y [km]\",\n   aspect = DataAspect()\n)\n\nlines!(ax, sol1, idxs = (1, 2))\n# Interpolate dimensionless solutions and map back to SI units\nxp, yp = let trange = range(tspan2..., length = 40)\n   sol2.(trange, idxs = 1) .* l₀, sol2.(trange, idxs = 2) .* l₀\nend\nlines!(ax, xp, yp, linestyle = :dashdot, linewidth = 5, color = Makie.wong_colors()[2])\ninvL = inv(1e3)\nscale!(ax.scene, invL, invL)\n\n\n(Image: )\n\nWe see that the results are almost identical, with only floating point numerical errors. Tracing in dimensionless units usually allows larger timesteps, which leads to faster computation.\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_flux/#demo_flux","page":"Flux","title":"Flux","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis demo shows how to estimate particle flux using TestParticle.jl. For the flux estimation to be accurate, we need to guarantee that\n\nThe number of test particles are enough to avoid statistical errors.\nThe source is properly selected. For instance, we usually sample from plasma moments of a known density, velocity and pressure. n*U gives us the source flux in units of [particles / s / m²]. If our source plane does not include all the possible sources, we will underestimate the target flux. Therefore, we need to make sure that our source plane covers all the launching possibilities, e.g. a closed sphere. Under the steady state assumption, we use the source launching time T in the denominator of calculating the flux. This time cancels out since there is also a T in the numerator.\n\nThe target flux is then estimated as\n\nJ = mathrmh  mathrmN oint_mathrmsource nmathbfUmathrmdS  oint_mathrmtarget mathrmdS\n\nwhere mathrmh is the number of particles that pass through the target and mathrmN is the total number of test particles.\n\nIn magnetosphere studies, to estimate the surface flux from ion precipitation, we can use a prescribed EM field to trace test particles originating from a closed source sphere. After a sufficiently long tracing time, each particle will either impact the surface or not. The total number flux [particles / s] is then obtained by counting all impacting particles, while the flux density [particles / s / m²] is determined by counting the impacting particles within a specific area.\n\nusing TestParticle, OrdinaryDiffEqTsit5, StaticArrays\n\nzeroB(x) = SA[0.0, 0.0, 0.0]\nzeroE(x) = SA[0.0, 0.0, 0.0]\n\n\"\"\"\nSet initial conditions.\n\"\"\"\nfunction prob_func(prob, i, repeat)\n   it = (i - 1) ÷ source_flux_tp\n   ir = (i - 1) % source_flux_tp\n   # initial velocity, [m/s]\n   if ir < source_flux_tp ÷ 2\n      v₀ = [1.0, 0.0, 0.0]\n   else\n      v₀ = [2.0, 0.0, 0.0]\n   end\n   # initial position, [m]\n   r₀ = prob.u0[1:3]\n   t = (prob.tspan[1] + it, prob.tspan[2])\n\n   prob = remake(prob; u0 = [r₀..., v₀...], tspan = t)\nend\n\n# Source flux at the origin\nsource_flux = 100 # [real particle / s]\n\nparam = prepare(zeroE, zeroB)\nstateinit = zeros(6) # particle position and velocity to be modified\n# Give particles enough time to reach steady state\ntspan = (-50.0, 100.0)\nconst tp_per_rp = 10 # test particle per real particle\nconst launch_time = 20 # [s], test particle launching lasting time\nconst source_flux_tp = source_flux ÷ tp_per_rp # [test particles / s]\ntrajectories = source_flux ÷ tp_per_rp * launch_time # total number of test particles\n\n200\n\nThe number of test particles is usually smaller than the real particles. In this case, one test particle represents tp_per_rp real particles. Assuming steady state, the time for recording the particles is the same as the launch time. We also assume that no particles have reached the plane before we count.\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nensemble_prob = EnsembleProblem(prob; prob_func, safetycopy = false)\n\nsols = solve(ensemble_prob, Tsit5(), EnsembleSerial(); trajectories)\n\n\"\"\"\nEstimate the particle flux through a plane x = x0 in a given time range.\n\"\"\"\nfunction estimate_flux_plane(sols, x0, trange = sols[1].prob.tspan)\n   count = 0\n   for sol in sols\n      xs = [sol(t)[1] for t in trange]\n      if xs[1] ≤ x0 ≤ xs[2] || xs[1] ≥ x0 ≥ xs[2]\n         count += 1\n      end\n   end\n   count *= tp_per_rp\n   count /= launch_time\nend\n\nplane_loc = 100.0 # [m]\ncount_time = (0.0, tspan[2]) # [s]\nflux = estimate_flux_plane(sols, plane_loc, count_time)\nprintln(\"Example 1:\")\nprintln(\"Particle flux through plane x = $plane_loc [m]: \", flux, \" /s\")\n\nExample 1:\nParticle flux through plane x = 100.0 [m]: 100.0 /s\n\n\nIn this example, we assume zero EM fields with constant particle velocities along the x-direction. The estimated particle flux shall match the source flux in this example. However, in general cases the particle flux through a given surface should be equal or smaller than the source flux. We should also take the area into account.\n\nThe second case assumes a point source at the origin. Particles are constantly isotropically launched from the source. We try to estimate the particle flux through a sphere at radius r.\n\nfunction sample_unit_velocity_spherical()\n   ϕ = 2 * π * rand()    # Azimuthal angle in [0, 2π)\n   cosθ = 2 * rand() - 1 # Uniformly sample cos(θ) in [-1, 1]\n   sinθ = sqrt(1 - cosθ^2)\n   x = sinθ * cos(ϕ)\n   y = sinθ * sin(ϕ)\n   z = cosθ\n   return SA[x, y, z]\nend\n\nfunction prob_func_iso(prob, i, repeat)\n   it = (i - 1) ÷ source_flux_tp\n   # initial velocity, [m/s]\n   v₀ = sample_unit_velocity_spherical()\n   # initial position, [m]\n   r₀ = prob.u0[1:3]\n   t = (prob.tspan[1] + it, prob.tspan[2])\n\n   prob = remake(prob; u0 = [r₀..., v₀...], tspan = t)\nend\n\nensemble_prob = EnsembleProblem(prob; prob_func = prob_func_iso, safetycopy = false)\n\nsols = solve(ensemble_prob, Tsit5(), EnsembleSerial(); trajectories)\n\n\"\"\"\nEstimate the particle flux through a sphere with radius r = r0 in a given time range.\n\"\"\"\nfunction estimate_flux_sphere(sols, r0, trange = sols[1].prob.tspan)\n   count = 0\n   for sol in sols\n      rs = [hypot(sol(t)[1:3]...) for t in trange]\n      if rs[1] ≤ r0 ≤ rs[2] || rs[1] ≥ r0 ≥ rs[2]\n         count += 1\n      end\n   end\n   count *= tp_per_rp\n   count /= launch_time\nend\n\nr = 100.0 # [m]\narea = 4π*r^2 # [m²]\ncount_time = (0.0, tspan[2]) # [s]\nflux = estimate_flux_sphere(sols, r, count_time)\nprintln(\"Example 2:\")\nprintln(\"Particle flux through sphere r = $r [m]: \", flux, \" /s\")\nprintln(\"Particle flux density through sphere r = $r [m]: \", flux / area, \" /(s * m²)\")\n\nExample 2:\nParticle flux through sphere r = 100.0 [m]: 100.0 /s\nParticle flux density through sphere r = 100.0 [m]: 0.0007957747154594767 /(s * m²)\n\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_Buniform_Ezero/#demo_uniformB_zeroE","page":"Helix motion","title":"Helix motion","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates a single proton motion under a uniform B field. The E field is assumed to be zero such that there is no particle acceleration.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing TestParticle: ZeroField\nusing CairoMakie\n\nuniform_B(x) = SA[0.0, 0.0, 1e-8]\nzero_E = ZeroField()\n\n# Initial condition\nstateinit = let x0 = [1.0, 0, 0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 18)\n\nparam = prepare(zero_E, uniform_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\n# Visualization\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Helix Trajectory\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\n\nplot!(ax, sol, idxs = (1, 2, 3))\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_gc/#demo_GC","page":"Guiding Center Approximation","title":"Guiding Center Approximation","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates how to solve the guiding center (GC) equations directly using TestParticle.jl. More theoretical details can be found in Guiding Center.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nimport TestParticle as TP\nusing CairoMakie\n\nfunction curved_B(x)\n   # satisify ∇ ⋅ B = 0\n   # B_θ = 1/r => ∂B_θ/∂θ = 0\n   θ = atan(x[3] / (x[1] + 3))\n   r = sqrt((x[1] + 3)^2 + x[3]^2)\n   return SA[-1e-6 * sin(θ) / r, 0, 1e-6 * cos(θ) / r]\nend\n\nuniform_B(x) = SA[0.0, 0.0, 1e-8]\nuniform_E(x) = SA[1e-9, 0.0, 0.0]\n\n# Initial condition\nstateinit = let x0 = [1.0, 0, 0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 41)\n\nparam = prepare(uniform_E, curved_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\nstateinit_gc,\nparam_gc = TP.prepare_gc(stateinit, uniform_E, curved_B,\n   species = Proton, removeExB = false)\n\nprob_gc = ODEProblem(trace_gc!, stateinit_gc, tspan, param_gc)\n\nsol_gc = solve(prob_gc, Vern9())\n\n# Test for numerical fields\nxrange = range(0.9, 1.1, length = 20)\nyrange = range(-0.45, 0.042, length = 60)\nzrange = range(-0.65, 0.65, length = 40)\n\nB_numerical = Array{Float64, 4}(undef, 3, length(xrange), length(yrange), length(zrange))\n\nfor k in eachindex(zrange), j in eachindex(yrange), i in eachindex(xrange)\n   x = SA[xrange[i], yrange[j], zrange[k]]\n   B_numerical[:, i, j, k] = curved_B(x)\nend\n##TODO Higher order interpolation leads to worse results --- needs investigations!\nstateinit_gc,\nparam_gc = TP.prepare_gc(stateinit, xrange, yrange, zrange,\n   uniform_E, B_numerical, species = Proton, removeExB = false, order = 1)\n\nprob_gc = ODEProblem(trace_gc_1st!, stateinit_gc, tspan, param_gc)\n\nsol_gc_numericBfield = solve(prob_gc, Vern9())\n\n# analytical drifts\ngc = param |> get_gc_func\ngc_x0 = gc(stateinit) |> Vector\nprob_gc_analytic = ODEProblem(trace_gc_drifts!, gc_x0, tspan, (param..., sol))\nsol_gc_analytic = solve(prob_gc_analytic, Vern9(); save_idxs = [1, 2, 3])\n\n# Functions for obtaining the guiding center from actual trajectory\ngc_plot(x, y, z, vx, vy, vz) = (gc([x, y, z, vx, vy, vz])...,)\n\n# Visualization\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Proton and Its Guiding Center Trajectories\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\n\nplot!(ax, sol, idxs = (1, 2, 3), color = (Makie.wong_colors()[1], 0.2))\nplot!(ax, sol_gc, idxs = (1, 2, 3), color = Makie.wong_colors()[2])\nplot!(ax, sol_gc_numericBfield, idxs = (1, 2, 3), color = Makie.wong_colors()[3])\nlines!(ax, sol_gc_analytic, idxs = (1, 2, 3), color = Makie.wong_colors()[4])\nlines!(ax, sol, idxs = (gc_plot, 1, 2, 3, 4, 5, 6), color = Makie.wong_colors()[5])\n\n\n(Image: )\n\nIt is important to satisfy the strict scale requirements for the GC approximation, i.e. the gyro-radius must be much smaller than the characteristic spatial scales of the EM fields (on the order of 0.01) for the finite-Larmor-radius (FLR) 1st order approximation to be valid. Consider the following example of grad-B drift:\n\nuniform_E(x) = SA[1e-9, 0.0, 0.0]\ngrad_B(x) = SA[0, 0, 1e-8 + 1e-9 * x[2]]\n\ntspan = (0, 20)\nstateinit = let x0 = [1.0, 0, 0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n\nstateinit_gc,\nparam_gc = TP.prepare_gc(stateinit, uniform_E, grad_B,\n   species = Proton, removeExB = false)\n\nprob_gc = ODEProblem(trace_gc_1st!, stateinit_gc, tspan, param_gc)\n\nsol_gc = solve(prob_gc, Vern9())\n\n# analytical drifts\nparam = prepare(uniform_E, grad_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\ngc = param |> get_gc_func\ngc_x0 = gc(stateinit) |> Vector\nprob_gc_analytic = ODEProblem(trace_gc_drifts!, gc_x0, tspan, (param..., sol))\nsol_gc_analytic = solve(prob_gc_analytic, Vern9(); save_idxs = [1, 2, 3])\n\n# Visualization\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Proton and Its Guiding Center Trajectories\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\n\nplot!(ax, sol, idxs = (1, 2, 3), color = (Makie.wong_colors()[1], 0.4))\nplot!(ax, sol_gc, idxs = (1, 2, 3), color = Makie.wong_colors()[2])\nlines!(ax, sol_gc_analytic, idxs = (1, 2, 3), color = Makie.wong_colors()[3])\nlines!(ax, sol, idxs = (gc_plot, 1, 2, 3, 4, 5, 6), color = Makie.wong_colors()[4])\n\n\n(Image: )\n\nWe can clearly see the deviations caused by the FLR effect. If we use a smaller gyro-radius by increasing the magnetic field, this accuracy will be much higher:\n\ngrad_B(x) = SA[0, 0, 1e-7 + 1e-8 * x[2]]\n\ntspan = (0, 10)\nstateinit_gc,\nparam_gc = TP.prepare_gc(stateinit, uniform_E, grad_B,\n   species = Proton, removeExB = false)\n\nprob_gc = ODEProblem(trace_gc_1st!, stateinit_gc, tspan, param_gc)\n\nsol_gc = solve(prob_gc, Vern9())\n\n# analytical drifts\nparam = prepare(uniform_E, grad_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\ngc = param |> get_gc_func\ngc_x0 = gc(stateinit) |> Vector\nprob_gc_analytic = ODEProblem(trace_gc_drifts!, gc_x0, tspan, (param..., sol))\nsol_gc_analytic = solve(prob_gc_analytic, Vern9(); save_idxs = [1, 2, 3])\n\n# Visualization\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Proton and Its Guiding Center Trajectories\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\n\nplot!(ax, sol, idxs = (1, 2, 3), color = (Makie.wong_colors()[1], 0.4))\nplot!(ax, sol_gc, idxs = (1, 2, 3), color = Makie.wong_colors()[2])\nlines!(ax, sol_gc_analytic, idxs = (1, 2, 3), color = Makie.wong_colors()[3])\nlines!(ax, sol, idxs = (gc_plot, 1, 2, 3, 4, 5, 6), color = Makie.wong_colors()[4])\n\n\n(Image: )\n\nTherefore, it is crucial to check the scale before performing any GC tracing!\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_radiation/#demo_radiation","page":"Radiation","title":"Radiation","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nFor an electron undergoing gyromotion in a constant magnetic field, the energy loss is caused by the emission of electromagnetic radiation. The rate of this energy loss (radiated power P) depends on whether the electron's speed is relativistic or non-relativistic. This phenomenon is generally divided into two regimes: Cyclotron Radiation (non-relativistic) and Synchrotron Radiation (relativistic).\n\nGeneral Formula (Relativistic)\n\nFor an electron with charge e, mass m, and velocity v moving in a magnetic field B, the total radiated power P is given by the relativistic generalization of the Larmor formula:\n\nP = frace^4 B^2 gamma^2 v_perp^26 pi epsilon_0 m^2 c^3\n\nAlternatively, using beta = vc and the pitch angle alpha (where v_perp = v sin alpha), this is often expressed as:\n\nP = frace^4 B^2 gamma^2 beta^2 sin^2 alpha6 pi epsilon_0 m^2 c\n\nwhere:\n\ngamma = frac1sqrt1 - beta^2\nis the Lorentz factor.\nepsilon_0\nis the vacuum permittivity.\nc\nis the speed of light.\nalpha\nis the pitch angle between the velocity vector and the magnetic field vector.\n\nNote on Emission Pattern: In the relativistic regime (gamma gg 1), the radiation is beamed forward in a narrow cone along the direction of the electron's instantaneous velocity (the \"searchlight effect\"), which is characteristic of Synchrotron radiation.\n\nNon-Relativistic Limit (Cyclotron Radiation)\n\nWhen the electron speed is much less than the speed of light (beta ll 1 and gamma approx 1), the formula simplifies to the classical Cyclotron radiation formula:\n\nP approx frace^4 B^2 v_perp^26 pi epsilon_0 m^2 c^3\n\nUsing the Thomson cross-section sigma_T = frace^46 pi epsilon_0^2 m^2 c^4 and magnetic energy density U_B = fracB^22mu_0, this can be written elegantly as:\n\nP = 2 sigma_T c U_B beta_perp^2\n\nEnergy Loss Per Turn\n\nIn accelerator physics, it is often useful to know the energy lost per complete revolution. For a highly relativistic electron (beta approx 1) moving in a circle of radius rho (where rho approx fracEe c B), the energy loss per turn delta E is:\n\ndelta E = oint P  dt = frace^23 epsilon_0 rho gamma^4\n\nThis gamma^4 dependence explains why circular electron accelerators (synchrotrons) become inefficient at very high energies—doubling the energy increases the radiative loss by a factor of 16.\n\nCooling Time\n\nThe electron will lose energy over time, causing its orbit to decay. The characteristic cooling time tau (the time scale over which the electron loses a significant fraction of its energy) is:\n\ntau approx fracEP approx frac3 m^3 c^52 e^4 B^2 gamma\n\nIn the non-relativistic limit, this simplifies to tau approx frac3 m^3 c^54 e^4 B^2 (note the independence from energy in the classical limit).\n\nAll the above equations are shown in CGS units.\n\nusing TestParticle: qᵢ as e, mₑ, c, ϵ₀\nusing CairoMakie\n\nPhysics Functions\n\n\"\"\"\n    calc_gamma(β)\n\nCalculate the Lorentz factor γ given β (v/c).\n\"\"\"\nfunction calc_gamma(β)\n   if β >= 1.0\n      return Inf\n   end\n   return 1.0 / sqrt(1.0 - β^2)\nend\n\n\"\"\"\n    radiated_power(B, β, α)\n\nCalculate the instantaneous power radiated by an electron in a magnetic field.\nBased on the relativistic generalization of the Larmor formula.\n\nParameters:\nB: Magnetic field strength [Tesla]\nβ: Normalized velocity (v/c)\nα: Pitch angle [radians] (angle between v and B)\n\nReturns:\nP     : Radiated Power [Watts]\n\"\"\"\nfunction radiated_power(B, β, α)\n   gamma = calc_gamma(β)\n\n   # Formula: P = (e^4 * B^2 * γ^2 * v_perp^2) / (6 * π * ϵ₀ * m^2 * c^3)\n   # Substitute v_perp = v * sin(α) = β * c * sin(α)\n   # Result: P = (e^4 * B^2 * γ^2 * β^2 * sin(α)^2) / (6 * π * ϵ₀ * m^2 * c)\n\n   numerator = e^4 * B^2 * gamma^2 * β^2 * sin(α)^2\n   denominator = 6 * π * ϵ₀ * (mₑ^2) * c\n\n   return numerator / denominator\nend\n\nMain.var\"##349\".radiated_power\n\nVisualization\n\nfunction main()\n   fig = Figure(size = (1200, 900), fontsize = 18)\n\n   # --- Plot: Power vs Magnetic Field B ---\n   # Fixed parameters\n   beta_fixed_1 = 0.9\n   alpha_fixed_1 = π / 2 # Perpendicular\n\n   B_range = range(0.1, 10.0, length = 200) # 0.1 T to 10 T\n   P_B = radiated_power.(B_range, beta_fixed_1, alpha_fixed_1)\n\n   ax1 = Axis(fig[1, 1],\n      title = L\"Power vs. Magnetic Field ($B$)\",\n      xlabel = \"Magnetic Field B [T]\",\n      ylabel = \"Power [W]\",\n      xscale = log10,\n      yscale = log10\n   )\n   lines!(ax1, B_range, P_B, color = :blue, linewidth = 3,\n      label = L\"\\beta = 0.9, \\alpha = 90^\\circ\")\n   axislegend(ax1, position = :lt)\n   text!(ax1, B_range[10], P_B[10], text = L\"P \\propto B^2\", align = (:left, :bottom))\n\n   # --- Plot: Power vs Velocity (β) ---\n   # Fixed parameters\n   B_fixed_2 = 1.0 # 1 Tesla\n   alpha_fixed_2 = π / 2\n\n   # Range close to 1 to show relativistic effects\n   beta_range = range(0.1, 0.999, length = 500)\n   P_beta = radiated_power.(B_fixed_2, beta_range, alpha_fixed_2)\n\n   ax2 = Axis(fig[1, 2],\n      title = L\"Power vs. Velocity ($\\beta$)\",\n      xlabel = L\"Velocity $\\beta = v/c$\",\n      ylabel = \"Power [W]\",\n      yscale = log10\n   )\n   lines!(ax2, beta_range, P_beta, color = :red, linewidth = 3,\n      label = L\"B = 1\\text{ T}, \\alpha = 90^\\circ\")\n   axislegend(ax2, position = :lt)\n\n   # --- Plot: Power vs Pitch Angle (α) ---\n   # Fixed parameters\n   B_fixed_3 = 1.0\n   beta_fixed_3 = 0.9\n\n   alpha_range = range(0, π, length = 360)\n   alpha_deg = rad2deg.(alpha_range)\n   P_alpha = radiated_power.(B_fixed_3, beta_fixed_3, alpha_range)\n\n   ax3 = Axis(fig[2, 1],\n      title = L\"Power vs. Pitch Angle ($\\alpha$)\",\n      xlabel = \"Pitch Angle [Degrees]\",\n      ylabel = \"Power [W]\",\n      xticks = 0:30:180\n   )\n   lines!(ax3, alpha_deg, P_alpha, color = :green,\n      linewidth = 3, label = L\"B=1\\text{ T}, \\beta=0.9\")\n   # Add a visual marker for max power\n   vlines!(ax3, [90], color = :black, linestyle = :dash)\n   axislegend(ax3)\n\n   # --- Plot: Heatmap (Log Power) vs B and β ---\n   # Here we vary both B and β\n   B_hm = range(0.1, 5.0, length = 100)\n   beta_hm = range(0.5, 0.999, length = 100)\n\n   # Calculate matrix\n   P_matrix = log10.(radiated_power.(B_hm, beta_hm', π / 2))\n\n   ax4 = Axis(fig[2, 2],\n      title = \"Log10(Power) Heatmap\",\n      xlabel = \"Magnetic Field B [T]\",\n      ylabel = L\"Velocity $\\beta$\"\n   )\n   hm = heatmap!(ax4, B_hm, beta_hm, P_matrix, colormap = :inferno)\n   Colorbar(fig[2, 3], hm, label = \"Log10(Power [W])\")\n\n   Label(fig[0, :], \"Electron Cyclotron/Synchrotron Radiation Loss\",\n      fontsize = 24, font = :bold)\n\n   fig\nend\n\nmain (generic function with 1 method)\n\nRun the visualization\n\nf = main()\n\n\n(Image: )\n\nWe need to consider radiation effects when the timescale of energy loss (the \"cooling time\") becomes comparable to or shorter than the characteristic timescale of our system (e.g., confinement time, acceleration time, or simulation duration).\n\ntau approx fracEP = frac6 pi epsilon_0 m^3 c^3e^4 B^2 gamma = frac52B^2 gamma text seconds (where B is in Tesla)\n\nWeak Fields / Low Energy: If B=1text T and the electron is non-relativistic\n\n(gamma approx 1), tau approx 5 seconds. You can safely ignore radiation.\n\nStrong Fields / High Energy: If B=5text T and you have a 1 GeV electron\n\n(gamma approx 2000), then tau approx 25 milliseconds.\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"plotfunctions/#Plot-Functions","page":"Plot Functions","title":"Plot Functions","text":"TestParticle.jl wraps types of AbstractODESolution from DifferentialEquations.jl. The plotting recipes for Plots.jl and Makie.jl work automatically for the particle tracing solutions.\n\nBefore using the plot recipes of Testparticle.jl, you need to import Makie package via using GLMakie or using CairoMakie, which depends on your choice for the backend. All plot recipes depend on Makie.jl.","category":"section"},{"location":"plotfunctions/#Convention","page":"Plot Functions","title":"Convention","text":"By convention, we use integers to represent the 7 dimensions in the input argument idxs for all plotting methods:\n\nComponent Meaning\n0 time\n1 x\n2 y\n3 z\n4 vx\n5 vy\n6 vz","category":"section"},{"location":"plotfunctions/#Basic-recipe","page":"Plot Functions","title":"Basic recipe","text":"The simplest usage is directly calling the plot or lines function provided by Makie. For example,\n\nplot(sol, idxs=(1, 2, 3))\n\nThe keyword argument idxs can be used to select the variables to be plotted; if not specified, it will plot the timeseries of x, y, z, vx, vy, vz. Please refer to Choose Variables for details.\n\nIf you want to plot a function of time, position or velocity, you can first define the function. For example,\n\nEₖ(t, vx, vy, vz) = (t, mₑ*(vx^2 + vy^2 + vz^2)/2)\nlines(sol, idxs=(Eₖ, 0, 4, 5, 6))\n\nwill plot the kinetic energy as a function of x.\n\nYou can choose the plotting time span via the keyword argument tspan. For example,\n\nlines(sol, tspan=(0, 1))\n\nThe plots can be customized further:\n\nf = Figure(size=(1200, 800), fontsize=18)\nax = Axis3(f[1,1],\n    title = \"Particle trajectory\",\n    xlabel = \"X\",\n    ylabel = \"Y\",\n    zlabel = \"Z\",\n)\n\nplot!(sol, idxs=(1, 2, 3))\n\nMultiple particle trajectories saved as the type EnsembleSolution is also supported by the Makie recipe.","category":"section"},{"location":"plotfunctions/#Advanced-recipe","page":"Plot Functions","title":"Advanced recipe","text":"note: Note\nWe currently rely on the Makie recipe implemented in DiffEqBase.jl. This recipe depends on an experimental API introduced in Makie v0.20, which may be unstable and contains bugs. Once it becomes more stabilized with bug fixes, we will recover the interactive widgets support, e.g. orbit and monitor.","category":"section"},{"location":"plotfunctions/#orbit","page":"Plot Functions","title":"orbit","text":"(Image: )\n\nThe slider can control the time span, and the maximum of time span will be displayed on the right of the slider.\n\nThe reset button can reset the scale of lines when the axis limits change. When you drag the slider, clicking reset button will reset the axis limits to fit the data.","category":"section"},{"location":"plotfunctions/#monitor","page":"Plot Functions","title":"monitor","text":"<video width=\"75%\" height=\"auto\" controls loop>\n<source src=\"https://raw.githubusercontent.com/TCLiuu/TestParticleResource/master/videos/monitor.mp4?raw=true\" type=\"video/mp4\">\n</video>\n\n(Image: )\n\nAfter first click of the run button, the evolution of the orbit will be displayed from the beginning. For other times, it will start from the time set by the time slider. The functionality of reset button is the same as above.\n\nThe time slider controls the time span. The speed slider controls the speed of the animation.","category":"section"},{"location":"examples/advanced/demo_output_func/#demo_output_func","page":"Ensemble tracing with extra saving","title":"Ensemble tracing with extra saving","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example demonstrates tracing multiple protons in an analytic E field and numerical B field. See Demo: single tracing with additional diagnostics for explaining the unit conversion. Also check Demo: Ensemble for basic usages of the ensemble problem.\n\nThe output_func argument can be used to change saving outputs. It works as a reduction function, but here we demonstrate how to add additional outputs. Besides the regular outputs, we also save the magnetic field along the trajectory, together with the parallel velocity.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing TestParticle: get_BField\nusing Statistics\nusing LinearAlgebra: normalize, ×, ⋅\nusing Random\nusing CairoMakie\n\nseed = 1 # seed for random number\nRandom.seed!(seed)\n\n\"\"\"\nSet initial state for EnsembleProblem.\n\"\"\"\nfunction prob_func(prob, i, repeat)\n   B0 = get_BField(prob)(prob.u0)\n   B0 = normalize(B0)\n\n   Bperp1 = SA[0.0, -B0[3], B0[2]] |> normalize\n   Bperp2 = B0 × Bperp1 |> normalize\n\n   # initial azimuthal angle\n   ϕ = 2π*rand()\n   # initial pitch angle\n   θ = acos(0.5)\n\n   sinϕ, cosϕ = sincos(ϕ)\n   u = @. (B0*cos(θ) + Bperp1*(sin(θ)*cosϕ) + Bperp2*(sin(θ)*sinϕ)) * U₀\n\n   prob = @views remake(prob; u0 = [prob.u0[1:3]..., u...])\nend\n\nfunction getmeanB(B)\n   B₀sum = eltype(B)(0)\n   for k in axes(B, 4), j in axes(B, 3), i in axes(B, 2)\n      B₀sum += B[1, i, j, k]^2 + B[2, i, j, k]^2 + B[3, i, j, k]^2\n   end\n\n   sqrt(B₀sum / prod(size(B)[2:4]))\nend\n\n# Number of cells for the field along each dimension\nnx, ny, nz = 4, 6, 8\n# Spatial coordinates given in customized units\nx = range(0, 1, length = nx)\ny = range(0, 1, length = ny)\nz = range(0, 1, length = nz)\n# Numerical magnetic field given in customized units\nB = Array{Float32, 4}(undef, 3, nx, ny, nz)\n\nB[1, :, :, :] .= 0.0\nB[2, :, :, :] .= 0.0\nB[3, :, :, :] .= 2.0\n\n# Reference values for unit conversions between the customized and dimensionless units\nconst B₀ = getmeanB(B)\nconst U₀ = 1.0\nconst l₀ = 2*nx\nconst t₀ = l₀ / U₀\nconst E₀ = U₀ * B₀;\n\nConvert from customized to default dimensionless units\n\n# Dimensionless spatial extents [l₀]\nx /= l₀\ny /= l₀\nz /= l₀\n# For full EM problems, the normalization of E and B should be done separately.\nB ./= B₀\nE(x) = SA[0.0 / E₀, 0.0 / E₀, 0.0 / E₀]\n\n# By default User type assumes q=1, m=1\n# bc=2 uses periodic boundary conditions\nparam = prepare(x, y, z, E, B; species = User, bc = 2)\n\n# Initial condition\nstateinit = let\n   x0 = [0.0, 0.0, 0.0] # initial position [l₀]\n   u0 = [1.0, 0.0, 0.0] # initial velocity [v₀]\n   [x0..., u0...]\nend\n# Time span\ntspan = (0.0, 2π) # one averaged gyroperiod based on B₀\n\nsaveat = tspan[2] / 40 # save interval\n\nprob = ODEProblem(trace_normalized!, stateinit, tspan, param)\n\n\"\"\"\nSet customized outputs for the ensemble problem.\n\"\"\"\nfunction output_func(sol, i)\n   getB = get_BField(sol)\n   b = getB.(sol.u)\n\n   μ = [@views b[i] ⋅ sol[4:6, i] / sqrt(sum(x -> x^2, b[i])) for i in eachindex(sol)]\n\n   (sol.u, b, μ), false\nend\n\n# Number of trajectories\ntrajectories = 2\n\nensemble_prob = EnsembleProblem(prob; prob_func, output_func, safetycopy = false)\nsols = solve(ensemble_prob, Vern9(), EnsembleThreads(); trajectories, saveat);\n\nVisualization\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Proton trajectories\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   zlabel = \"Z\",\n   aspect = :data\n)\n\nfor i in eachindex(sols)\n   xp = [s[1] for s in sols[i][1]]\n   yp = [s[2] for s in sols[i][1]]\n   zp = [s[3] for s in sols[i][1]]\n   lines!(ax, xp, yp, zp, label = \"$i\")\nend\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"This section contains thorough examples for using TestParticle.jl. If you prefer to run the demos on your local computer with interactive support, we suggest switching from using CairoMakie (which is a Makie frontend for static 2D rendering) to using GLMakie (which is another Makie frontend for interactive 3D rendering).\n\n","category":"section"},{"location":"examples/#Basics","page":"Examples","title":"Basics","text":"<div class=\"list-card-section\">\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nEnergy Conservation\n\n</div>\n    <div class=\"list-card-description\">\n\nDemonstrate energy conservation in uniform fields.\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nBoris method\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple electron trajectory under uniform B and zero E\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nHelix motion\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple proton trajectory under uniform B and zero E\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nDimensionless Units\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing charged particle in dimensionless units\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nTracing with Dimensionless Units and Periodic Boundary\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing charged particle in dimensionless units and periodic boundary\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nDimensionless and Dimensional Tracing\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing charged particle in both dimensional and dimensionless units.\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nProton and electron in a static EM field\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple particle trajectories under uniform B and zero E\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nMultiple particles\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing multiple charged particles in a static EM field\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nE×B drift\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple ExB drift demonstration\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nExF drift\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple proton trajectory under uniform B and gravity\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nGrad-B drift\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple magnetic field gradient drift demonstration\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nCurl-B drift\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple magnetic field curvature drift demonstration\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nFinite-Larmor-Radius effect\n\n</div>\n    <div class=\"list-card-description\">\n\nFinite Larmor radius effect demonstration using Makie\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nPolarization drift\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple polarization drift under time-varying E field\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nArray Shape Conversion\n\n</div>\n    <div class=\"list-card-description\">\n\nF-style and C-style array conversion\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n</div>","category":"section"},{"location":"examples/#Advanced","page":"Examples","title":"Advanced","text":"<div class=\"list-card-section\">\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nAdvanced Boris tracing\n\n</div>\n    <div class=\"list-card-description\">\n\nBoris ensemble tracing with field out-of-domain check\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nCosmic Ray Tracing\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing cosmic ray charged particles\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nEnsemble tracing\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing multiple charged particles in a static EM field\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nFlux\n\n</div>\n    <div class=\"list-card-description\">\n\nEstimation of particle flux\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nSingle tracing with additional diagnostics\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing one charged particle with additional diagnostics\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nEnsemble tracing with extra saving\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing multiple charged particles in a static EM field\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nCurrent sheet\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing charged particle in the Harris current sheet\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nMagnetic mirror\n\n</div>\n    <div class=\"list-card-description\">\n\nCharged particle in the magnetic mirror\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nElectron in a magnetic bottle\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing charged particle in a magnetic bottle\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nMagnetic dipole\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing charged particle in a static analytic dipole magnetic field\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nAnalytical magnetosphere\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing charged particle in an analytical magnetosphere\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nShock\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing charged particle in an MHD plane shock\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nElectron Fermi Acceleration Inside Foreshock Transient Cores\n\n</div>\n    <div class=\"list-card-description\">\n\nFermi acceleration demonstration\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nTracing in spherical coordinates\n\n</div>\n    <div class=\"list-card-description\">\n\nSimple proton trajectory under uniform B defined in spherical coordinates.\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nCoil Tokamak\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing protons in a Tokamak\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nTokamak profile\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing passing and trapped proton in a Tokamak\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nGuiding Center Approximation\n\n</div>\n    <div class=\"list-card-description\">\n\nDemonstrate the GC solvers\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nTracing particle from PIC\n\n</div>\n    <div class=\"list-card-description\">\n\nThis demo shows how to trace particles from structured SWMF outputs\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nRadiation\n\n</div>\n    <div class=\"list-card-description\">\n\nEstimation of particle radiation\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nGPU Ensemble tracing\n\n</div>\n    <div class=\"list-card-description\">\n\nTracing multiple charged particles in a static EM field using GPU\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n</div>\n\n","category":"section"},{"location":"examples/advanced/demo_batsrus_3dstructured/#demo_pic","page":"Tracing particle from PIC","title":"Tracing particle from PIC","text":"(Image: Author) (Image: Update time)\n\nThis example shows how to trace charged particles in the structured SWMF outputs from an MHD-EPIC simulation of Ganymede. For more details about the field file format, please checkout Batsrus.jl.\n\nusing Statistics: mean\nusing Batsrus\nusing TestParticle\nusing OrdinaryDiffEq\nusing FieldTracer\nusing PyPlot\n\n## Utility functions\n\nfunction initial_conditions(i)\n   j = i - 1\n   [x[xc_], y[yc_+j], z[zc_], Uix[xc_,yc_+j,zc_], Uiy[xc_,yc_+j,zc_], Uiz[xc_,yc_+j,zc_]]\nend\n\n\"Set initial conditions.\"\nfunction prob_func(prob, i, repeat)\n   remake(prob, u0=initial_conditions(i))\nend\n\n## Data processing\n\nfilename = \"3d_var_region0_0_t00002500_n00106468.out\"\ndata = readdata(filename)\n\nvar = getvars(data, [\"Bx\", \"By\", \"Bz\", \"Ex\", \"Ey\", \"Ez\", \"uxs0\", \"uys0\", \"uzs0\", \"uxs1\", \"uys1\", \"uzs1\"])\n\nconst RG = 2634e3 # [m]\n\nx = range(extrema(data.x[:,:,:,1])..., length=size(data.x, 1)) .* RG\ny = range(extrema(data.x[:,:,:,2])..., length=size(data.x, 2)) .* RG\nz = range(extrema(data.x[:,:,:,3])..., length=size(data.x, 3)) .* RG\nB = zeros(Float32, 3, length(x), length(y), length(z)) # [T]\nE = zeros(Float32, 3, length(x), length(y), length(z)) # [V/m]\n\n# Convert into SI units\nB[1,:,:,:] .= var[\"Bx\"] .* 1e-9\nB[2,:,:,:] .= var[\"By\"] .* 1e-9\nB[3,:,:,:] .= var[\"Bz\"] .* 1e-9\nE[1,:,:,:] .= var[\"Ex\"] .* 1e-6\nE[2,:,:,:] .= var[\"Ey\"] .* 1e-6\nE[3,:,:,:] .= var[\"Ez\"] .* 1e-6\n\n## Initial conditions\n\nUex, Uey, Uez = var[\"uxs0\"] .* 1e3, var[\"uys0\"] .* 1e3, var[\"uzs0\"] .* 1e3\nUix, Uiy, Uiz = var[\"uxs1\"] .* 1e3, var[\"uys1\"] .* 1e3, var[\"uzs1\"] .* 1e3\n\nxc_ = floor(Int, length(x)/2) + 1\nyc_ = floor(Int, length(y)/2) + 1\nzc_ = floor(Int, length(z)/2) + 1\n\nstateinit_e = [x[xc_], y[yc_], z[zc_], Uex[xc_,yc_,zc_], Uey[xc_,yc_,zc_], Uez[xc_,yc_,zc_]]\nstateinit_p = [x[xc_], y[yc_], z[zc_], Uix[xc_,yc_,zc_], Uiy[xc_,yc_,zc_], Uiz[xc_,yc_,zc_]]\n\nparam_electron = prepare(x, y, z, E, B, species=Electron)\ntspan_electron = (0.0, 0.1)\n\nparam_proton = prepare(x, y, z, E, B, species=Proton)\ntspan_proton = (0.0, 10.0)\ntrajectories = 5\n\nprob_p = ODEProblem(trace!, stateinit_p, tspan_proton, param_proton)\nensemble_prob = EnsembleProblem(prob_p, prob_func=prob_func)\nsol_p = solve(ensemble_prob, Vern9(), EnsembleThreads(); trajectories)\n\n## Visualization\n\nusing3D()\nfig = plt.figure(figsize=(10,6))\nax = fig.gca(projection=\"3d\")\n\n## Field tracing\n\nfor i in 1:10:length(x)\n   xs, ys, zs = x[i], 0.0, 0.0\n   x1, y1, z1 = trace(B[1,:,:,:], B[2,:,:,:], B[3,:,:,:], xs, ys, zs, x, y, z, ds=0.2, maxstep=1000)\n   line = ax.plot(x1 ./ RG, y1 ./RG, z1 ./ RG, \"k-\", alpha=0.3)\nend\n\nfor i in 1:10:length(y)\n   xs, ys, zs = x[xc_], y[i], z[zc_]\n   x1, y1, z1 = trace(B[1,:,:,:], B[2,:,:,:], B[3,:,:,:], xs, ys, zs, x, y, z, ds=0.2, maxstep=1000)\n   line = ax.plot(x1 ./ RG, y1 ./RG, z1 ./ RG, \"k-\", alpha=0.3)\nend\n\nn = 200 # number of timepoints\n\nts = range(0, stop=tspan_proton[2], length=n)\nfor i = 1:trajectories\n   if sol_p[i].t[end] < tspan_proton[2]\n      ts⁺ = range(0, stop=sol_p[i].t[end], length=n)\n      ax.plot(sol_p[i](ts⁺,idxs=1) ./ RG, sol_p[i](ts⁺,idxs=2) ./ RG, sol_p[i](ts⁺,idxs=3) ./ RG, label=\"proton $i\", lw=1.5)\n   else\n      ax.plot(sol_p[i](ts,idxs=1) ./ RG, sol_p[i](ts,idxs=2) ./ RG, sol_p[i](ts,idxs=3) ./ RG, label=\"proton $i\", lw=1.5)\n   end\nend\n\n#ax.plot(sol_p[1,:], sol_p[2,:], sol_p[3,:], label=\"proton\")\n\nax.legend()\ntitle(\"Particle trajectory near Ganymede's magnetopause from PIC\")\nxlabel(\"x [Rg]\")\nylabel(\"y [Rg]\")\nzlabel(\"z [Rg]\")\n\nax.set_box_aspect([1.17,4,4])\nTestParticle.set_axes_equal(ax)\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl.","category":"section"},{"location":"examples/basics/demo_boris/#demo_boris","page":"Boris method","title":"Boris method","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example demonstrates a single electron motion under a uniform B field. The E field is assumed to be zero such that there is no particle acceleration. We use the Boris method for phase space conservation under a fixed time step. This is compared against other ODE general algorithms for performance and accuracy.\n\nusing TestParticle, OrdinaryDiffEq, StaticArrays\nusing TestParticle: ZeroField, get_BField\nimport TestParticle as TP\nusing CairoMakie\n\nfunction plot_trajectory(sol_boris, sol1, sol2)\n   f = Figure(size = (700, 600), fontsize = 18)\n   ax = Axis(f[1, 1], aspect = 1, limits = (-3, 1, -2, 2),\n      xlabel = \"X\",\n      ylabel = \"Y\")\n   idxs = (1, 2)\n   l0 = lines!(ax, sol_boris[1]; idxs, linewidth = 2, label = \"Boris\")\n   l1 = lines!(ax, sol1; idxs,\n      color = Makie.wong_colors()[2], linewidth = 2, linestyle = :dashdot, label = \"Tsit5 fixed\")\n   l2 = linesegments!(ax, sol2; idxs,\n      color = Makie.wong_colors()[3], linewidth = 2, linestyle = :dot, label = \"Tsit5 adaptive\")\n\n   scale!(ax.scene, invrL, invrL)\n\n   axislegend(position = :rt, framevisible = false)\n\n   f\nend\n\nconst Bmag = 0.01\nuniform_B(x) = SA[0.0, 0.0, Bmag]\nzero_E = ZeroField()\n\nx0 = [0.0, 0.0, 0.0]\nv0 = [0.0, 1e5, 0.0]\nstateinit = [x0..., v0...]\n\nparam = prepare(zero_E, uniform_B, species = Electron)\n\n# Reference parameters\nconst tperiod = 2π / (abs(param[1]) *\n                 sqrt(sum(x -> x^2, get_BField(param)([0.0, 0.0, 0.0], 0.0))))\nconst rL = sqrt(v0[1]^2 + v0[2]^2 + v0[3]^2) / (abs(param[1]) * Bmag)\nconst invrL = 1 / rL;\n\nWe first trace the particle for one period with a discrete time step of a quarter period.\n\ntspan = (0.0, tperiod)\ndt = tperiod / 4\n\nprob = TraceProblem(stateinit, tspan, param)\n\nsol_boris = TP.solve(prob; dt, savestepinterval = 1);\n\nLet's compare against the default ODE solver Tsit5 from DifferentialEquations.jl, in both fixed time step mode and adaptive mode:\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol1 = solve(prob, Tsit5(); adaptive = false, dt, dense = false, saveat = dt);\nsol2 = solve(prob, Tsit5());\n\n# Visualization\nf = plot_trajectory(sol_boris, sol1, sol2)\n\n(Image: )\n\nIt is clear that the Boris method comes with larger phase errors (mathcalO(Delta t)) compared with Tsit5. The phase error gets smaller using a smaller dt:\n\ndt = tperiod / 8\n\nprob = TraceProblem(stateinit, tspan, param)\n\nsol_boris = TP.solve(prob; dt, savestepinterval = 1);\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol1 = solve(prob, Tsit5(); adaptive = false, dt, dense = false, saveat = dt);\n\n# Visualization\nf = plot_trajectory(sol_boris, sol1, sol2)\n\n(Image: )\n\nThe Boris pusher shines when we do long time tracing, which is fast and conserves energy:\n\ntspan = (0.0, 200 * tperiod)\ndt = tperiod / 12\n\nprob_boris = TraceProblem(stateinit, tspan, param)\nprob = ODEProblem(trace!, stateinit, tspan, param)\n\nsol_boris = TP.solve(prob_boris; dt, savestepinterval = 10);\nsol1 = solve(prob, Tsit5(); adaptive = false, dt, dense = false, saveat = dt);\nsol2 = solve(prob, Tsit5());\nsol3 = solve(prob, Vern7());\nsol4 = solve(prob, Vern9());\n\n# Visualization\nf = plot_trajectory(sol_boris, sol1, sol2)\n\n(Image: )\n\nFixed time step Tsit5() is ok, but adaptive Tsit5() is pretty bad for long time evolutions. The change in radius indicates change in energy, which is sometimes known as numerical heating.\n\nE(vx, vy, vz) = 1 // 2 * (vx^2 + vy^2 + vz^2)\nf = Figure(size = (800, 400), fontsize = 18)\nax = Axis(f[1, 1],\n   xlabel = \"time [period]\",\n   ylabel = \"Normalized Kinetic Energy\")\n\nsols_to_plot = [\n   (sol_boris[1], \"Boris\"),\n   (sol1, \"Tsit5 fixed\"),\n   (sol2, \"Tsit5 adaptive\"),\n   (sol3, \"Vern7 adaptive\"),\n   (sol4, \"Vern9 adaptive\")\n]\n\nfor (sol, label) in sols_to_plot\n   energy = map(x -> E(x[4:6]...), sol.u)\n   lines!(ax, sol.t ./ tperiod, energy ./ energy[1], label = label)\nend\n\naxislegend(ax, position = :lt)\n\n\n(Image: )\n\nAnother aspect to compare is performance:\n\n@time sol_boris = TP.solve(prob_boris; dt, savestepinterval = 10)[1];\n@time sol1 = solve(prob, Tsit5(); adaptive = false, dt, dense = false, saveat = dt);\n@time sol2 = solve(prob, Tsit5());\n@time sol3 = solve(prob, Vern7());\n@time sol4 = solve(prob, Vern9());\n\n  0.000105 seconds (272 allocations: 22.250 KiB)\n  0.000745 seconds (4.89 k allocations: 364.203 KiB)\n  0.000686 seconds (23.69 k allocations: 1.314 MiB)\n  0.000649 seconds (23.08 k allocations: 1.311 MiB)\n  0.000744 seconds (18.58 k allocations: 1.065 MiB)\n\n\nWe can extract the solution (x, y, z, vx, vy, vz) at any given time by performing a linear interpolation:\n\nt = tspan[2] / 2\nsol_boris(t)\n\n6-element StaticArraysCore.MVector{6, Float64} with indices SOneTo(6):\n    -3.911568318655031e-5\n    -5.5137270837814596e-5\n     0.0\n 99639.26547015733\n  8486.269885387323\n     0.0\n\nThe Boris method is faster and consumes less memory. However, in practice, it is pretty hard to find an optimal algorithm. When calling OrdinaryDiffEq.jl, we recommend using Vern9() as a starting point instead of Tsit5(), especially combined with adaptive timestepping. Further fine-grained control includes setting dtmax, reltol, and abstol in the solve method.\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_FLR/#demo_FLR","page":"Finite-Larmor-Radius effect","title":"Finite-Larmor-Radius effect","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThe general FLR effect refers to the correction terms introduced when considering the field difference at the particle location and the guiding center location. More theoretical details can be found in Non-uniform E Field.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing LinearAlgebra: ×, ⋅, norm, normalize\nusing Tensors: laplace\nimport Tensors: Vec as Vec3\n# using SpecialFunctions\nusing CairoMakie\n\nuniform_B(x) = SA[0, 0, 1e-8]\n\nnonuniform_E(x) = SA[1e-9 * cos(0.3 * x[1]), 0, 0]\n\n# trace the orbit of the guiding center\nfunction trace_gc!(dx, x, p, t)\n   q2m, _, E, B, _, sol = p\n   xu = sol(t)\n   xp = @view xu[1:3]\n   Bv = B(xp)\n   b = normalize(Bv)\n   v_par = (xu[4:6] ⋅ b) .* b # (v ⋅ b)b\n   v_perp = xu[4:6] - v_par\n   r4 = (norm(v_perp) / q2m / norm(Bv))^2 / 4\n   EB(x) = (E(x) × B(x)) / norm(B(x))^2\n   # dx[1:3] = EB(xp) + v_par\n   dx[1:3] = EB(x) + r4*laplace.(EB, Vec3(x...)) + v_par\n\n   # more accurate\n   # dx[1:3] = besselj0(0.3*norm(v_perp)/q2m/norm(Bv))*EB(x) + v_par\nend\n\n# Initial condition\nstateinit = let x0 = [1.0, 0, 0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 20)\nparam = prepare(nonuniform_E, uniform_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\ngc = param |> get_gc_func\ngc_x0 = gc(stateinit) |> Vector\nprob_gc = ODEProblem(trace_gc!, gc_x0, tspan, (param..., sol))\nsol_gc = solve(prob_gc, Vern7(); save_idxs = [1, 2, 3])\n\n# numeric result and analytic result\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Finite Larmor Radius Effect\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data,\n   azimuth = 0.3π\n)\n\ngc_plot(x, y, z, vx, vy, vz) = (gc(SA[x, y, z, vx, vy, vz])...,)\n\nlines!(ax, sol, idxs = (1, 2, 3), color = Makie.wong_colors()[1])\nlines!(ax, sol, idxs = (gc_plot, 1, 2, 3, 4, 5, 6), color = Makie.wong_colors()[2])\nlines!(ax, sol_gc, idxs = (1, 2, 3), color = Makie.wong_colors()[3])\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_energy_conservation/#demo_energy_conservation","page":"Energy Conservation","title":"Energy Conservation","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example demonstrates the energy conservation of a single proton motion in two cases. The first one is under a uniform B field and zero E field. The second on is under a zero B field and uniform E field.\n\nusing TestParticle, OrdinaryDiffEq, StaticArrays\nusing TestParticle: ZeroField\nimport TestParticle as TP\nusing LinearAlgebra: ×\nusing CairoMakie\n\nconst B₀ = 1e-8 # [T]\nconst E₀ = 3e-2 # [V/m]\n\n\"\"\"\nf2\n\"\"\"\nlocation!(dx, v, x, p, t) = dx .= v\n\n\"\"\"\nf1\n\"\"\"\nfunction lorentz!(dv, v, x, p, t)\n   q2m, _, E, B = p\n   dv .= q2m*(E(x, t) + v × (B(x, t)))\nend\n\n### Initialize field\n\nuniform_B(x) = SA[0, 0, B₀]\n\nuniform_E(x) = SA[E₀, 0.0, 0.0]\n\nzero_B = ZeroField()\nzero_E = ZeroField()\n\n\"\"\"\nCheck energy conservation.\n\"\"\"\nE(vx, vy, vz) = 1 // 2 * (vx^2 + vy^2 + vz^2)\n\n### Initialize particles\n\nx0 = [0.0, 0, 0]\nv0 = [0.0, 1e2, 0.0]\nstateinit = [x0..., v0...]\ntspan_proton = (0.0, 2000.0);\n\nUniform B field and zero E field\n\nparam_proton = prepare(zero_E, uniform_B, species = Proton)\n\n### Solve for the trajectories\n\nprob_p = DynamicalODEProblem(lorentz!, location!, v0, x0, tspan_proton, param_proton)\n\nΩᵢ = TP.qᵢ * B₀ / TP.mᵢ\nTᵢ = 2π / Ωᵢ\nprintln(\"Number of gyrations: \", tspan_proton[2] / Tᵢ)\n\nsol = solve(prob_p, ImplicitMidpoint(), dt = Tᵢ/15)\n\nf = Figure(fontsize = 18)\nax = Axis(f[1, 1],\n   title = \"Proton in a uniform B field and zero E field\",\n   xlabel = \"x\",\n   ylabel = \"y\",\n   aspect = 1\n)\n\nlines!(ax, sol, idxs = (1, 2))\n\n\n(Image: )\n\nZero B field and uniform E field\n\nparam_proton = prepare(uniform_E, zero_B, species = Proton)\n\n# acceleration, [m/s²]\na = param_proton[1] * E₀\n# predicted final speed, [m/s]\nv_final_predict = a * tspan_proton[2]\n# predicted travel distance, [m/s]\nd_final_predict = 0.5 * tspan_proton[2] * v_final_predict\n# predicted energy gain, [eV]\nE_predict = E₀ * d_final_predict\n\nprob_p = DynamicalODEProblem(lorentz!, location!, v0, x0, tspan_proton, param_proton)\n\nsol = solve(prob_p, Vern6())\n\nenergy = map(x -> E(x[1:3]...), sol.u) .* TP.mᵢ;\n\nPredicted final speed\n\npredicted final speed: 5.744086746808526e9 [m/s]\n\n\nSimulated final speed\n\nsimulated final speed: 5.744086746808613e9 [m/s]\n\n\nPredicted travel distance\n\npredicted travel distance: 5.744086746808526e12 [m]\n\n\nSimulated travel distance\n\nsimulated travel distance: 5.74408674676843e12 [m]\n\n\nPredicted final energy\n\npredicted energy gain: 1.723226024042558e11 [eV]\n\n\nSimulated final energy\n\nsimulated final energy: 1.7232260240426102e11 [eV]\n\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_analytic_magnetosphere/#demo_analytic_magnetosphere","page":"Analytical magnetosphere","title":"Analytical magnetosphere","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis demo shows how to trace particles in a vacuum superposition of a dipolar magnetic field mathbfB_D with a uniform background magnetic field mathbfB_mathrmIMF. In this slightly modified dipole field, magnetic null points appear near 14 Earth's radii, and the particle orbits are also distorted from the idealized motions in Demo: magnetic dipole.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing TestParticle: getB_dipole, getE_dipole, sph2cart, mᵢ, qᵢ, c, Rₑ\nusing FieldTracer\nusing CairoMakie\n\ngetB_superposition_constant(xu) = getB_dipole(xu) + SA[0.0, 0.0, -10e-9]\n\nfunction getB_superposition_harris(xu)\n   Bt = 0.01 * 4e-5 # [T], 1% of the dipole field at the equator\n   δ = 0.1Rₑ # [m]\n   Bx = Bt * tanh(-xu[3] / δ)\n   getB_dipole(xu) + SA[Bx, 0.0, 0.0]\nend\n\n\"\"\"\nBoundary condition check.\n\"\"\"\nfunction isoutofdomain(u, p, t)\n   rout = 18Rₑ\n   if (u[1]^2 + u[2]^2 + u[3]^2) < (1.1Rₑ)^2 ||\n      abs(u[1]) > rout || abs(u[2]) > rout || abs(u[3]) > rout\n      return true\n   else\n      return false\n   end\nend\n\n\"\"\"\nSet initial conditions.\n\"\"\"\nfunction prob_func_13(prob, i, repeat)\n   # initial particle energy\n   Ek = 5e3 # [eV]\n   # initial velocity, [m/s]\n   v₀ = sph2cart(c*sqrt(1-1/(1+Ek*qᵢ/(mᵢ*c^2))^2), π/4, 0.0)\n   # initial position, [m]\n   r₀ = sph2cart(13*Rₑ, π*i, π/2)\n\n   prob = remake(prob; u0 = [r₀..., v₀...])\nend\n\nfunction prob_func_6(prob, i, repeat)\n   # initial particle energy\n   Ek = 4e3 # [eV]\n   # initial velocity, [m/s]\n   v₀ = sph2cart(c*sqrt(1-1/(1+Ek*qᵢ/(mᵢ*c^2))^2), π/4, 0.0)\n   # initial position, [m]\n   r₀ = sph2cart(6*Rₑ, π/2, 2π*i)\n\n   prob = remake(prob; u0 = [r₀..., v₀...])\nend\n\n# obtain field\nparam = prepare(getE_dipole, getB_superposition_constant)\nstateinit = zeros(6) # particle position and velocity to be modified\ntspan = (0.0, 2000.0)\ntrajectories = 2\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nensemble_prob = EnsembleProblem(prob; prob_func = prob_func_13, safetycopy = false)\n\n# See https://docs.sciml.ai/DiffEqDocs/stable/basics/common_solver_opts/\n# for the solver options\nsols = solve(ensemble_prob, Vern9(), EnsembleSerial(); reltol = 1e-5,\n   trajectories, isoutofdomain, dense = true, save_on = true)\n\n### Visualization\n\nf = Figure(fontsize = 18)\n##ax = Axis3(f[1, 1],\n#   title = \"5 keV Protons in a vacuum superposition magnetosphere\",\n#   xlabel = \"x [Re]\",\n#   ylabel = \"y [Re]\",\n#   zlabel = \"z [Re]\",\n#   aspect = :data,\n#   limits = (-14, 14, -14, 14, -5, 5)\n##)\nax = LScene(f[1, 1])\n\nfor (i, sol) in enumerate(sols)\n   l = lines!(ax, sol, idxs = (1, 2, 3), color = Makie.wong_colors()[i])\nend\ninvRE = 1 / Rₑ\n# In Makie 0.21.11, scene scaling has issues on Axis3.\n##scale!(ax.scene, invRE, invRE, invRE)\n\n# Field lines\nfunction get_numerical_field(x, y, z, model)\n   bx = zeros(length(x), length(y), length(z))\n   by = similar(bx)\n   bz = similar(bx)\n\n   for i in CartesianIndices(bx)\n      pos = [x[i[1]], y[i[2]], z[i[3]]]\n      bx[i], by[i], bz[i] = model(pos)\n   end\n\n   bx, by, bz\nend\n\nfunction trace_field!(ax, x, y, z, unitscale, model = getB_superposition_constant;\n      rmin = 8Rₑ, rmax = 16Rₑ, nr = 8, nϕ = 4)\n   bx, by, bz = get_numerical_field(x, y, z, model)\n\n   zs = 0.0\n   dϕ = 2π / nϕ\n   for r in range(rmin, rmax, length = nr), ϕ in range(0, 2π-dϕ, length = nϕ)\n\n      xs = r * cos(ϕ)\n      ys = r * sin(ϕ)\n\n      x1, y1,\n      z1 = FieldTracer.trace(bx, by, bz, xs, ys, zs, x, y, z; ds = 0.1, maxstep = 10000)\n\n      lines!(ax, x1, y1, z1, color = :gray)\n      ##lines!(ax, x1.*unitscale, y1.*unitscale, z1.*unitscale, color=:gray)\n   end\nend\n\nx = range(-18Rₑ, 18Rₑ, length = 50)\ny = range(-18Rₑ, 18Rₑ, length = 50)\nz = range(-18Rₑ, 18Rₑ, length = 50)\n\ntrace_field!(ax, x, y, z, invRE)\n\n\n(Image: )\n\nWe now look at another superposition model of a dipole and a Harris current sheet.\n\nparam = prepare(getE_dipole, getB_superposition_harris)\nstateinit = zeros(6) # particle position and velocity to be modified\ntspan = (0.0, 8000.0)\ntrajectories = 1\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nensemble_prob = EnsembleProblem(prob; prob_func = prob_func_6, safetycopy = false)\n\nsols = solve(ensemble_prob, Vern9(), EnsembleSerial(); reltol = 1e-5,\n   trajectories, isoutofdomain, dense = true, save_on = true)\n\nx = range(-10Rₑ, 10Rₑ, length = 50)\ny = range(-5Rₑ, 5Rₑ, length = 20)\nz = range(-10Rₑ, 10Rₑ, length = 50)\n\nf = Figure(fontsize = 18)\nax = LScene(f[1, 1])\n\nfor (i, sol) in enumerate(sols)\n   l = lines!(ax, sol, idxs = (1, 2, 3), color = Makie.wong_colors()[i])\nend\n\nrotate!(ax.scene, Vec3f(0, 0, 1), 1.4)\ntrace_field!(ax, x, y, z, invRE, getB_superposition_harris; rmin = 4Rₑ, rmax = 8Rₑ, nϕ = 8)\nscale!(ax.scene, 4.0, 4.0, 4.0)\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"api/#Internal","page":"API","title":"Internal","text":"","category":"section"},{"location":"api/#Public-APIs","page":"API","title":"Public APIs","text":"","category":"section"},{"location":"api/#Private-types-and-methods","page":"API","title":"Private types and methods","text":"","category":"section"},{"location":"api/#TestParticle.BiMaxwellian","page":"API","title":"TestParticle.BiMaxwellian","text":"Type for BiMaxwellian velocity distributions with respect to the magnetic field.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.BiMaxwellian-Union{Tuple{U}, Tuple{T}, Tuple{AbstractVector{U}, AbstractVector{T}, Any, Any, Any}} where {T<:AbstractFloat, U<:AbstractFloat}","page":"API","title":"TestParticle.BiMaxwellian","text":" BiMaxwellian(B::Vector{U}, u0::Vector{T}, ppar, pperp, n; m=mᵢ)\n\nConstruct a BiMaxwellian distribution with magnetic field B, bulk velocity u0, parallel thermal pressure ppar, perpendicular thermal pressure pperp, and number density n in SI units. The default particle is proton.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.Cartesian","page":"API","title":"TestParticle.Cartesian","text":"Cartesian grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.Maxwellian","page":"API","title":"TestParticle.Maxwellian","text":"Type for Maxwellian velocity distributions.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.Maxwellian-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any}} where T","page":"API","title":"TestParticle.Maxwellian","text":" Maxwellian(u0::AbstractVector{T}, p, n; m=mᵢ)\n\nConstruct a Maxwellian distribution with bulk velocity u0, thermal pressure p, and number density n in SI units. The default particle is proton.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.Spherical","page":"API","title":"TestParticle.Spherical","text":"Spherical grid with uniform r, θ and ϕ.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.SphericalNonUniformR","page":"API","title":"TestParticle.SphericalNonUniformR","text":"Spherical grid with non-uniform r and uniform θ, ϕ.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.energy2velocity-Tuple{Any}","page":"API","title":"TestParticle.energy2velocity","text":"Return velocity magnitude from energy in [eV].\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.get_energy-Tuple{Any}","page":"API","title":"TestParticle.get_energy","text":"Calculate the energy [eV] of a relativistic particle from γv.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.get_energy-Tuple{SciMLBase.AbstractODESolution}","page":"API","title":"TestParticle.get_energy","text":"Return the energy [eV] from relativistic sol.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.get_gc-Tuple{Any, Any}","page":"API","title":"TestParticle.get_gc","text":" get_gc(xu, param)\n get_gc(x, y, z, vx, vy, vz, bx, by, bz, q2m)\n\nCalculate the coordinates of the guiding center according to the phase space coordinates of a particle. Reference: wiki\n\nNonrelativistic definition:\n\nmathbfX=mathbfx-mfracmathbfbtimesmathbfvqB\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.get_gc_func-Tuple{Any}","page":"API","title":"TestParticle.get_gc_func","text":" get_gc_func(param)\n\nReturn the function for plotting the orbit of guiding center.\n\nExample\n\nparam = prepare(E, B; species = Proton)\n# The definitions of stateinit, tspan, E and B are ignored.\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern7(); dt = 2e-11)\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1], aspect = :data)\ngc = param |> get_gc_func\ngc_plot(x, y, z, vx, vy, vz) = (gc(SA[x, y, z, vx, vy, vz])...,)\nlines!(ax, sol, idxs = (gc_plot, 1, 2, 3, 4, 5, 6))\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.get_gyrofrequency","page":"API","title":"TestParticle.get_gyrofrequency","text":"Return the gyrofrequency.\n\n\n\n\n\n","category":"function"},{"location":"api/#TestParticle.get_gyroperiod","page":"API","title":"TestParticle.get_gyroperiod","text":"Return the gyroperiod.\n\n\n\n\n\n","category":"function"},{"location":"api/#TestParticle.get_gyroradius-Tuple{AbstractFloat, AbstractFloat}","page":"API","title":"TestParticle.get_gyroradius","text":"Return the gyroradius.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.get_velocity-Tuple{Any}","page":"API","title":"TestParticle.get_velocity","text":"Return velocity from relativistic γv in sol.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.prepare","page":"API","title":"TestParticle.prepare","text":"prepare(args...; kwargs...) -> (q2m, m, E, B, F)\nprepare(E, B, F = ZeroField(); kwargs...)\nprepare(grid::CartesianGrid, E, B, F = ZeroField(); kwargs...)\nprepare(x, E, B, F = ZeroField(); dir = 1, kwargs...)\nprepare(x, y, E, B, F = ZeroField(); kwargs...)\nprepare(x, y, z, E, B, F = ZeroField(); kwargs...)\n\nReturn a tuple consists of particle charge-mass ratio for a prescribed species of charge q and mass m, mass m for a prescribed species, analytic/interpolated EM field functions, and external force F.\n\nPrescribed species are Electron and Proton; other species can be manually specified with species=Ion/User, q and m.\n\nDirect range input for uniform grid in 1/2/3D is supported. For 1D grid, an additional keyword dir is used for specifying the spatial direction, 1 -> x, 2 -> y, 3 -> z. For 3D grid, the default grid type is Cartesian. To use Spherical grid, an additional keyword gridtype is needed. For Spherical grid, dimensions of field arrays should be (Br, Bθ, Bϕ).\n\nKeywords\n\norder::Int=1: order of interpolation in [1,2,3].\nbc::Int=1: type of boundary conditions, 1 -> NaN, 2 -> periodic.\nspecies::Species=Proton: particle species.\nq=1.0: particle charge. Only works when Species=User.\nm=1.0: particle mass. Only works when Species=User.\ngridtype::Grid=Cartesian(): type of grid in Cartesian(), Spherical(), SphericalNonUniformR.\n\n\n\n\n\n","category":"function"},{"location":"api/#TestParticle.sample-Union{Tuple{Maxwellian{U, T}}, Tuple{T}, Tuple{U}} where {U, T}","page":"API","title":"TestParticle.sample","text":" sample(vdf::Maxwellian)\n\nSample a 3D velocity from a Maxwellian distribution vdf using the Box-Muller method.\n\n sample(vdf::BiMaxwellian)\n\nSample a 3D velocity from a BiMaxwellian distribution vdf using the Box-Muller method.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace!-NTuple{4, Any}","page":"API","title":"TestParticle.trace!","text":"trace!(dy, y, p, t)\n\nODE equations for charged particle moving in static EM field and external force field with in-place form.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace-Tuple{Any, Any, Any}","page":"API","title":"TestParticle.trace","text":"trace(y, p, t) -> SVector{6, Float64}\n\nODE equations for charged particle moving in static EM field and external force field with out-of-place form.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace_gc!-Tuple{Any, Any, Tuple{Float64, Float64, Float64, TestParticle.AbstractField, TestParticle.AbstractField}, Any}","page":"API","title":"TestParticle.trace_gc!","text":" trace_gc!(dy, y, p, t)\n\nGuiding center equations for nonrelativistic charged particle moving in static EM field with in-place form. Variable y = (x, y, z, u), where u is the velocity along the magnetic field at (x,y,z).\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace_gc_1st!-Tuple{Any, Any, Tuple{Float64, Float64, Float64, TestParticle.AbstractField, TestParticle.AbstractField}, Any}","page":"API","title":"TestParticle.trace_gc_1st!","text":"1st order approximation of guiding center equations.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace_gc_drifts!-NTuple{4, Any}","page":"API","title":"TestParticle.trace_gc_drifts!","text":" trace_gc_drifts!(dx, x, p, t)\n\nEquations for tracing the guiding center using analytical drifts, including the grad-B drift, curvature drift, and ExB drift. Parallel velocity is also added. This expression requires the full particle trajectory p.sol.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace_normalized!-NTuple{4, Any}","page":"API","title":"TestParticle.trace_normalized!","text":" trace_normalized!(dy, y, p, t)\n\nNormalized ODE equations for charged particle moving in static EM field with in-place form. If the field is in 2D X-Y plane, periodic boundary should be applied for the field in z via the extrapolation function provided by Interpolations.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace_relativistic!-NTuple{4, Any}","page":"API","title":"TestParticle.trace_relativistic!","text":" trace_relativistic!(dy, y, p, t)\n\nODE equations for relativistic charged particle (x, γv) moving in static EM field with in-place form.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace_relativistic-Tuple{Any, Any, Any}","page":"API","title":"TestParticle.trace_relativistic","text":" trace_relativistic(y, p, t) -> SVector{6}\n\nODE equations for relativistic charged particle (x, γv) moving in static EM field with out-of-place form.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace_relativistic_normalized!-NTuple{4, Any}","page":"API","title":"TestParticle.trace_relativistic_normalized!","text":" trace_relativistic_normalized!(dy, y, p, t)\n\nNormalized ODE equations for relativistic charged particle (x, γv) moving in static EM field with in-place form.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.trace_relativistic_normalized-Tuple{Any, Any, Any}","page":"API","title":"TestParticle.trace_relativistic_normalized","text":" trace_relativistic_normalized(y, p, t)\n\nNormalized ODE equations for relativistic charged particle (x, γv) moving in static EM field with out-of-place form.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.AbstractTraceSolution","page":"API","title":"TestParticle.AbstractTraceSolution","text":"Abstract type for tracing solutions.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.Field","page":"API","title":"TestParticle.Field","text":" Field{itd, F} <: AbstractField{itd}\n\nA representation of a field function f, defined by:\n\ntime-independent field\n\nmathbfF = F(mathbfx)\n\ntime-dependent field\n\nmathbfF = F(mathbfx t)\n\nArguments\n\nfield_function::Function: the function of field.\nitd::Bool: whether the field function is time dependent.\nF: the type of field_function.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.GCTuple","page":"API","title":"TestParticle.GCTuple","text":"The type of parameter tuple for guiding center problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.Grid","page":"API","title":"TestParticle.Grid","text":"Type for grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.Species","page":"API","title":"TestParticle.Species","text":"Type for the particles, Proton, Electron, Ion, or User.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle.TraceSolution-Union{Tuple{Any}, Tuple{deriv}, Tuple{Any, Type{deriv}}} where deriv","page":"API","title":"TestParticle.TraceSolution","text":"Interpolate solution at time x. Forward tracing only.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.VDF","page":"API","title":"TestParticle.VDF","text":"Abstract type for velocity distribution functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#TestParticle._boris!-NTuple{8, Any}","page":"API","title":"TestParticle._boris!","text":"Apply Boris method for particles with index in irange.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle._prepare-Tuple{TraceProblem, Any, Any, Any}","page":"API","title":"TestParticle._prepare","text":"Prepare for advancing.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.cart2sph-Tuple{Any, Any, Any}","page":"API","title":"TestParticle.cart2sph","text":"Convert from Cartesian to spherical coordinates vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.cross!-Tuple{Any, Any, Any}","page":"API","title":"TestParticle.cross!","text":"In-place cross product.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.dipole-Tuple{Any, Any}","page":"API","title":"TestParticle.dipole","text":"Calculates the magnetic field from a dipole with magnetic moment M at r.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.dipole_fieldline","page":"API","title":"TestParticle.dipole_fieldline","text":" dipole_fieldline(ϕ, L=2.5, nP=100)\n\nCreates nP points on one field line of the magnetic field from a dipole. In a centered dipole magnetic field model, the path along a given L shell can be described as r = L*cos²λ, where r is the radial distance (in planetary radii) to a point on the line, λ is its co-latitude, and L is the L-shell of interest.\n\n\n\n\n\n","category":"function"},{"location":"api/#TestParticle.getB_CS_harris","page":"API","title":"TestParticle.getB_CS_harris","text":" getB_CS_harris(B₀, L)\n\nReturn the magnetic field at location r near a current sheet with magnetic strength B₀ and sheet length L. The current sheet is assumed to lie in the z = 0 plane.\n\n\n\n\n\n","category":"function"},{"location":"api/#TestParticle.getB_bottle-NTuple{8, Any}","page":"API","title":"TestParticle.getB_bottle","text":" getB_bottle(x, y, z, distance, a, b, I1, I2) -> StaticVector{Float64, 3}\n\nGet magnetic field from a magnetic bottle. Reference: wiki\n\nArguments\n\nx,y,z::Float: particle coordinates in [m].\ndistance::Float: distance between solenoids in [m].\na::Float: radius of each side coil in [m].\nb::Float: radius of central coil in [m].\nI1::Float: current in the solenoid times number of windings in side coils in [A].\nI2::Float: current in the central solenoid times number of windings in the central loop in [A].\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.getB_current_loop-Tuple{Any, Any, Any, TestParticle.Currentloop}","page":"API","title":"TestParticle.getB_current_loop","text":" getB_current_loop(x, y, z, cl::Currentloop) -> StaticVector{Float64, 3}\n\nGet magnetic field at [x, y, z] from a magnetic mirror generated from two coils.\n\nArguments\n\nx,y,z::Float: particle coordinates in [m].\ndistance::Float: distance between solenoids in [m].\na::Float: radius of each side coil in [m].\nI1::Float: current in the solenoid times number of windings in side coils.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.getB_dipole-Tuple{Any}","page":"API","title":"TestParticle.getB_dipole","text":"Analytic magnetic field function for testing. Return in SI unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.getB_mirror-NTuple{6, Any}","page":"API","title":"TestParticle.getB_mirror","text":" getB_mirror(x, y, z, distance, a, I1) -> StaticVector{Float64, 3}\n\nGet magnetic field at [x, y, z] from a magnetic mirror generated from two coils.\n\nArguments\n\nx,y,z::Float: particle coordinates in [m].\ndistance::Float: distance between solenoids in [m].\na::Float: radius of each side coil in [m].\nI1::Float: current in the solenoid times number of windings in side coils.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.getB_tokamak_coil-NTuple{7, Any}","page":"API","title":"TestParticle.getB_tokamak_coil","text":" getB_tokamak_coil(x, y, z, a, b, ICoils, IPlasma) -> StaticVector{Float64, 3}\n\nGet the magnetic field from a Tokamak topology consists of 16 coils. Original: Tokamak-Fusion-Reactor\n\nArguments\n\nx,y,z::Float: location in [m].\na::Float: radius of each coil in [m].\nb::Float: radius of central region in [m].\nICoil::Float: current in the coil times number of windings in [A].\nIPlasma::Float: current of the plasma in [A].\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.getB_tokamak_profile-Tuple{AbstractFloat, AbstractFloat, AbstractFloat, Any, AbstractFloat, AbstractFloat, AbstractFloat}","page":"API","title":"TestParticle.getB_tokamak_profile","text":" getB_tokamak_profile(x, y, z, q_profile, a, R₀, Bζ0) -> StaticVector{Float64, 3}\n\nReconstruct the magnetic field distribution from a safe factor(q) profile. Reference: Tokamak, 4th Edition, John Wesson.\n\nArguments\n\nx,y,z::Float: location in [m].\nq_profile::Function: profile of q. The variable of this function must be the normalized radius.\na::Float: minor radius [m].\nR₀::Float: major radius [m].\nBζ0::Float: toroidal magnetic field on axis [T].\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.getE_dipole-Tuple{Any}","page":"API","title":"TestParticle.getE_dipole","text":"Analytic electric field function for testing.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.get_interpolator-Union{Tuple{T}, Tuple{Cartesian, AbstractArray{T, 4}, Any, Any, Any}, Tuple{Cartesian, AbstractArray{T, 4}, Any, Any, Any, Int64}, Tuple{Cartesian, AbstractArray{T, 4}, Any, Any, Any, Int64, Int64}} where T","page":"API","title":"TestParticle.get_interpolator","text":" get_interpolator(A, gridx, gridy, gridz, order::Int=1, bc::Int=1)\n get_interpolator(gridtype, A, grid1, grid2, grid3, order::Int=1, bc::Int=1)\n\nReturn a function for interpolating field array A on the grid given by gridx, gridy, and gridz.\n\nArguments\n\ngridtype: Cartesian, Spherical or SphericalNonUniformR.\nA: field array. For vector field, the first dimension should be 3.\norder::Int=1: order of interpolation in [1,2,3].\nbc::Int=1: type of boundary conditions, 1 -> NaN, 2 -> periodic, 3 -> Flat.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.get_rotation_matrix-Tuple{AbstractVector{<:AbstractFloat}, Real}","page":"API","title":"TestParticle.get_rotation_matrix","text":" get_rotation_matrix(axis::AbstractVector, angle::Real) --> SMatrix{3,3}\n\nCreate a rotation matrix for rotating a 3D vector around a unit axis by an angle in radians. Reference: Rotation matrix from axis and angle\n\nExample\n\nusing LinearAlgebra\nv = [-0.5, 1.0, 1.0]\nv̂ = normalize(v)\nθ = deg2rad(-74)\nR = get_rotation_matrix(v̂, θ)\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.getchargemass-Tuple{TestParticle.Species, Real, Real}","page":"API","title":"TestParticle.getchargemass","text":" getchargemass(species::Species, q, m)\n\nReturn charge and mass for species. For species = Ion, q and m are charge and mass numbers. For species = User, the input q and m are returned as is.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.getinterp","page":"API","title":"TestParticle.getinterp","text":" getinterp(::Grid, A, gridx, gridy, gridz, order::Int=1, bc::Int=1)\n\nReturn a function for interpolating field array A on the grid given by gridx, gridy, and gridz.\n\nArguments\n\norder::Int=1: order of interpolation in [1,2,3].\nbc::Int=1: type of boundary conditions, 1 -> NaN, 2 -> periodic, 3 -> Flat.\ndir::Int: 1/2/3, representing x/y/z direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#TestParticle.getinterp_scalar","page":"API","title":"TestParticle.getinterp_scalar","text":" getinterp_scalar(::Grid, A, gridx, gridy, gridz, order::Int=1, bc::Int=1)\n\nReturn a function for interpolating scalar array A on the grid given by gridx, gridy, and gridz. Currently only 3D arrays are supported.\n\nArguments\n\norder::Int=1: order of interpolation in [1,2,3].\nbc::Int=1: type of boundary conditions, 1 -> NaN, 2 -> periodic, 3 -> Flat.\ndir::Int: 1/2/3, representing x/y/z direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#TestParticle.is_time_dependent-Tuple{Function}","page":"API","title":"TestParticle.is_time_dependent","text":"Judge whether the field function is time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.makegrid-Tuple{Meshes.CartesianGrid{M, C, N} where {M<:Meshes.𝔼, C<:CoordRefSystems.Cartesian, N}}","page":"API","title":"TestParticle.makegrid","text":"Return uniform range from 2D/3D CartesianGrid.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.set_axes_equal-Tuple{Any}","page":"API","title":"TestParticle.set_axes_equal","text":" set_axes_equal(ax)\n\nSet 3D plot axes to equal scale for Matplotlib. Make axes of 3D plot have equal scale so that spheres appear as spheres and cubes as cubes. Required since ax.axis('equal') and ax.set_aspect('equal') don't work on 3D.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.solve","page":"API","title":"TestParticle.solve","text":" solve(prob::TraceProblem; trajectories::Int=1, dt::AbstractFloat,\n\t savestepinterval::Int=1, isoutofdomain::Function=ODE_DEFAULT_ISOUTOFDOMAIN)\n\nTrace particles using the Boris method with specified prob.\n\nkeywords\n\ntrajectories::Int: number of trajectories to trace.\ndt::AbstractFloat: time step.\nsavestepinterval::Int: saving output interval.\nisoutofdomain::Function: a function with input of position and velocity vector xv that determines whether to stop tracing.\n\n\n\n\n\n","category":"function"},{"location":"api/#TestParticle.sph2cart-Tuple{Any, Any, Any}","page":"API","title":"TestParticle.sph2cart","text":"Convert from spherical to Cartesian coordinates vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.sph_to_cart_vector-NTuple{5, Any}","page":"API","title":"TestParticle.sph_to_cart_vector","text":"Convert a vector from spherical to Cartesian.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.update_location!-Tuple{Any, Any}","page":"API","title":"TestParticle.update_location!","text":"Update location in one timestep dt.\n\n\n\n\n\n","category":"method"},{"location":"api/#TestParticle.update_velocity!-NTuple{5, Any}","page":"API","title":"TestParticle.update_velocity!","text":" update_velocity!(xv, paramBoris, param, dt, t)\n\nUpdate velocity using the Boris method, Birdsall, Plasma Physics via Computer Simulation. Reference: DTIC\n\n\n\n\n\n","category":"method"},{"location":"examples/basics/demo_gravity_drift/#demo_uniformB_gravity","page":"ExF drift","title":"ExF drift","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates a single proton motion under uniform B and gravity fields.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing CairoMakie\n\n# Analytic EM fields\nB(x) = SA[0.0, 1e-8, 0.0]\nE(x) = SA[0.0, 0.0, 0.0]\n\n# Earth's gravity\nF(x) = SA[0.0, 0.0, -TestParticle.mᵢ * 9.8]\n\n# Initial static particle\nstateinit = let x0 = [1.0, 0.0, 0.0], v0 = [0.0, 0.0, 0.0]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 1.0)\n\nparam = prepare(E, B, F, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n# drift in x-direction + free fall in z-direction\nf = lines(sol, idxs = (3, 1);\n   figure = (; size = (800, 400), fontsize = 18),\n   axis = (;\n      title = \"ExF Drift\", xlabel = \"Z [m]\", ylabel = \"X [m]\", aspect = DataAspect())\n)\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_magneticbottle/#demo_electron_bottle","page":"Electron in a magnetic bottle","title":"Electron in a magnetic bottle","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace non-relativistic and relativistic electrons in a stationary magnetic field that corresponds to a magnetic bottle. Reference wiki\n\nusing TestParticle, OrdinaryDiffEq, StaticArrays\nimport TestParticle as TP\nusing Printf\nusing CairoMakie\n\n### Obtain field\n\n# Magnetic bottle parameters in SI units\nconst I1 = 20.0 # current in the solenoid\nconst N1 = 45 # number of windings\nconst I2 = 20.0 # current in the central solenoid\nconst N2 = 45 # number of windings\nconst distance = 10.0 # distance between solenoids\nconst a = 4.0 # radius of each coil\nconst b = 8.0 # radius of central coil\n\ngetB(xu) = SVector{3}(TP.getB_bottle(xu[1], xu[2], xu[3], distance, a, b, I1*N1, I2*N2))\n\ngetE(xu) = SA[0.0, 0.0, 0.0]\n\n### Initialize particles\nm = TP.mₑ\nq = TP.qₑ\nc = TP.c\n\n# initial velocity, [m/s]\nv₀ = [2.75, 2.5, 1.3] .* 0.03c  # confined\n# initial position, [m]\nr₀ = [0.8, 0.8, 0.0]\nstateinit = [r₀..., v₀...]\n\n# Theoretically we can take advantage of the fact that magnetic field does not\n# accelerate particles, so that γ remains constant. However, we are not doing\n# that here since it is not generally true in the EM field.\n\nparam = prepare(getE, getB; species = Electron)\ntspan = (0.0, 1e-5)\n\nprob_rel = ODEProblem(trace_relativistic!, stateinit, tspan, param)\nprob_non = ODEProblem(trace!, stateinit, tspan, param)\n\nvratio = √(v₀[1]^2+v₀[2]^2+v₀[3]^2)/c\nE = (1 / √(1 - vratio^2) - 1)*m*c^2/abs(q)/1e6\n\nv_str = @sprintf \"V = %4.2f %s\" vratio*100 \"% c\"\ne_str = @sprintf \"E = %6.4f MeV\" E\n\nprintln(v_str)\nprintln(e_str)\n\n# Default Tsit5() and many solvers does not work in this case!\nsol_rel = solve(prob_rel, AB4(); dt = 3e-9)\nsol_non = solve(prob_non, AB4(); dt = 3e-9)\n\n### Visualization\n\nf = Figure(fontsize = 18)\nax1 = Axis3(f[1, 1];\n   aspect = :data,\n   title = \"Relativistic e⁻, \\n\"*v_str*\", \"*e_str\n)\nax2 = Axis3(f[1, 2];\n   aspect = :data,\n   title = \"Non-relativistic e⁻, \\n\"*v_str*\", \"*e_str\n)\n\nlines!(ax1, sol_rel, idxs = (1, 2, 3))\nlines!(ax2, sol_non, idxs = (1, 2, 3))\n\n# Plot coils\nθ = range(0, 2π, length = 100)\nx = a .* cos.(θ)\ny = a .* sin.(θ)\nz = fill(distance/2, size(x))\nfor ax in (f[1, 1], f[1, 2])\n   lines!(ax, x, y, z, color = (:red, 0.7))\nend\nz = fill(-distance/2, size(x))\nfor ax in (f[1, 1], f[1, 2])\n   lines!(ax, x, y, z, color = (:red, 0.7))\nend\n\nx = b .* cos.(θ)\ny = b .* sin.(θ)\nz = fill(0.0, size(x))\nfor ax in (f[1, 1], f[1, 2])\n   lines!(ax, x, y, z, color = (:red, 0.7))\nend\n\nusing FieldTracer\n\nxrange = range(-4, 4, length = 20)\nyrange = range(-4, 4, length = 20)\nzrange = range(-10, 10, length = 20)\n\nBx, By, Bz = let x=xrange, y=yrange, z=zrange\n   Bx = zeros(length(x), length(y), length(z))\n   By = zeros(length(x), length(y), length(z))\n   Bz = zeros(length(x), length(y), length(z))\n   for k in eachindex(z), j in eachindex(y), i in eachindex(x)\n      Bx[i, j, k], By[i, j, k], Bz[i, j, k] = getB([x[i], y[j], z[k]])\n   end\n\n   Bx, By, Bz\nend\n\nfor i in 0:8\n   if i == 0\n      xs, ys, zs = 0.0, 0.0, 0.0\n   else\n      xs, ys, zs = 3*cos(2π*(i-1)/8), 3*sin(2π*(i-1)/8), 0.0\n   end\n   x1, y1,\n   z1 = FieldTracer.trace(Bx, By, Bz, xs, ys, zs, xrange, yrange, zrange;\n      ds = 0.1, maxstep = 1000)\n   for ax in (f[1, 1], f[1, 2])\n      lines!(ax, x1, y1, z1, color = :black)\n   end\nend\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_magneticmirror/#demo_magnetic_mirror","page":"Magnetic mirror","title":"Magnetic mirror","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates the particle motion trajectory in a magnetic mirror and also illustrates the conservation of magnetic moment. From the third figure on the right, it can be seen that the zero-order quantity of magnetic moment is conserved, but its high-order part is not conserved under this definition of magnetic moment and oscillates rapidly. We can observe from this the oscillation characteristics of magnetic moments at different levels.\n\nThis example is based on demo_magneticbottle.jl.\n\nusing TestParticle, OrdinaryDiffEq, StaticArrays\nimport TestParticle as TP\nusing LinearAlgebra: normalize, norm, ⋅\nusing CairoMakie\n\n### Obtain field\n\n# Magnetic mirror parameters in SI units\nconst I = 20.0 # current in the solenoid [A]\nconst N = 45 # number of windings\nconst distance = 10.0 # distance between solenoids [m]\nconst a = 4.0 # radius of each coil [m]\n\ngetB(xu) = SVector{3}(TP.getB_mirror(xu[1], xu[2], xu[3], distance, a, I*N))\n\ngetE(xu) = SA[0.0, 0.0, 0.0]\n\n# velocity in the direction perpendicular to the magnetic field\nfunction v_perp(t, x, y, z, vx, vy, vz)\n   xu = SA[x, y, z, vx, vy, vz]\n   vu = @view xu[4:6]\n   B = getB(xu)\n   b = normalize(B)\n   v_pa = (vu ⋅ b) .* b\n\n   (t, norm(vu - v_pa))\nend\n\n# magnetic field\nabsB(t, x, y, z) = (t, sqrt(sum(x -> x^2, getB(SA[x, y, z]))))\n\n# μ, magnetic moment\nfunction mu(t, x, y, z, vx, vy, vz)\n   xu = SA[x, y, z, vx, vy, vz]\n\n   (t, v_perp(t, x, y, z, vx, vy, vz)[2]^2 / sqrt(sum(x -> x^2, getB(xu))))\nend\n\nEt(xu) = sqrt(xu[4]^2 + xu[5]^2 + xu[6]^2)\n\n### Initialize particles\nm = TP.mₑ\nq = TP.qₑ\nc = TP.c\n\n# initial velocity, [m/s]\nv₀ = [2.75, 2.5, 1.3] .* 0.001c  # confined\n##v₀ = [0.25, 0.25, 5.9595] .* 0.01c  # escaped\n# initial position, [m]\nr₀ = [0.8, 0.8, 0.0]  # confined\n##r₀ = [1.5, 1.5, 2.4]  # escaped\nstateinit = [r₀..., v₀...]\n\nparam = prepare(getE, getB; species = Electron)\ntspan = (0.0, 1e-4)\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\n\n# Default Tsit5() and many solvers does not work in this case!\n# AB4() has better performance in maintaining magnetic moment conservation compared to AB3().\nsol_non = solve(prob, AB4(); dt = 3e-9)\n\n### Visualization\nf = Figure(size = (900, 600), fontsize = 18)\nax1 = Axis3(f[1:3, 1],\n   title = \"Magnetic Mirror\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data,\n   azimuth = 0.9π,\n   elevation = 0.1π\n)\nax2 = Axis(f[1, 2], xlabel = \"time [s]\", ylabel = \"B [T]\")\nax3 = Axis(f[2, 2], xlabel = \"time [s]\", ylabel = \"v_perp [m/s]\")\nax4 = Axis(f[3, 2], xlabel = \"time [s]\", ylabel = \"mu\")\n\nlines!(ax1, sol_non, idxs = (1, 2, 3))\nlines!(ax2, sol_non, idxs = (absB, 0, 1, 2, 3))\nlines!(ax3, sol_non, idxs = (v_perp, 0, 1, 2, 3, 4, 5, 6))\nlines!(ax4, sol_non, idxs = (mu, 0, 1, 2, 3, 4, 5, 6))\n\n# Plot coils\nθ = range(0, 2π, length = 100)\nx = a .* cos.(θ)\ny = a .* sin.(θ)\nz = fill(distance/2, size(x))\nlines!(ax1, x, y, z, color = :red)\nz = fill(-distance/2, size(x))\nlines!(ax1, x, y, z, color = :red)\n\n# # The distribution of magnetic field along the z-axis or x-axis\n# Bz(z) = hypot(getB(SA[0.0, 0.0, z])...)\n# Bx(x) = hypot(getB(SA[x, 0.0, 0.5*distance])...)\n# z = collect(-10:0.01:10)\n# x = collect(-0.99*a:0.01:0.99*a)\n# # Ba = Bz.(z)\n# Ba = Bx.(x)\n# # lines(z, Ba, color=:red)\n# lines(x, Ba, color=:red)\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_electron_proton/#demo_proton_electron","page":"Proton and electron in a static EM field","title":"Proton and electron in a static EM field","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates tracing a single proton and electron motion under a uniform B field in real physical parameters. The E field is assumed to be zero such that there is no particle acceleration. Due to the fact that m_p  m_e doteq 1836, the proton gyro-radius is 1800 times larger than the electron, if they start with the same velocity as in this case. In more common cases we would compare electrons and protons with the same energy, and their gyro-radii differ by a factor of sqrtm_pm_e sim 40.\n\nusing TestParticle, OrdinaryDiffEqVerner\nusing CairoMakie\n\n### Initialize grid and field\nx = range(-10, 10, length = 15)\ny = range(-10, 10, length = 20)\nz = range(-10, 10, length = 25)\n\nB = fill(0.0, 3, length(x), length(y), length(z)) # [T]\nE = fill(0.0, 3, length(x), length(y), length(z)) # [V/m]\nB[3, :, :, :] .= 1e-11\nE[3, :, :, :] .= 5e-13\n\n### Initialize particles\nstateinit = let\n   x0 = [0.0, 0.0, 0.0] # initial position, [m]\n   u0 = [1.0, 0.0, 0.0] # initial velocity, [m/s]\n   [x0..., u0...]\nend\nparam_electron = prepare(x, y, z, E, B, species = Electron)\ntspan_electron = (0.0, 15.0)\n\nparam_proton = prepare(x, y, z, E, B, species = Proton)\ntspan_proton = (0.0, 10.0)\n\n### Solve for the trajectories\nprob_e = ODEProblem(trace!, stateinit, tspan_electron, param_electron)\nprob_p = ODEProblem(trace!, stateinit, tspan_proton, param_proton)\n\nsol_e = solve(prob_e, Vern9())\nsol_p = solve(prob_p, Vern9())\n\n### Visualization\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Electron and Ion Trajectories\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\nplot!(sol_e, idxs = (1, 2, 3), color = :tomato, label = \"electron\")\nplot!(sol_p, idxs = (1, 2, 3), color = :deepskyblue3, label = \"proton\")\n\naxislegend()\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_dimensionless_periodic/#demo_dimensionless_periodic","page":"Tracing with Dimensionless Units and Periodic Boundary","title":"Tracing with Dimensionless Units and Periodic Boundary","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace charged particles in dimensionless units and EM fields with periodic boundaries in a 2D spatial domain. For details about dimensionless units, please check Demo: dimensionless tracing.\n\nNow let's demonstrate this with trace_normalized!.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing TestParticle: qᵢ, mᵢ\nusing CairoMakie\n\n# Number of cells for the field along each dimension\nnx, ny = 4, 6\n# Unit conversion factors between SI and dimensionless units\nB₀ = 10e-9            # [T]\nΩ = abs(qᵢ) * B₀ / mᵢ # [1/s]\nt₀ = 1 / Ω            # [s]\nU₀ = 1.0              # [m/s]\nl₀ = U₀ * t₀          # [m]\nE₀ = U₀*B₀            # [V/m]\n\nx = range(-10, 10, length = nx) # [l₀]\ny = range(-10, 10, length = ny) # [l₀]\n\nB = fill(0.0, 3, nx, ny) # [B₀]\nB[3, :, :] .= 1.0\n\nE(x) = SA[0.0, 0.0, 0.0] # [E₀]\n\n# If bc == 1, we set a NaN value outside the domain (default);\n# If bc == 2, we set periodic boundary conditions.\nparam = prepare(x, y, E, B; species = User, bc = 2);\n\nNote that we set a radius of 10, so the trajectory extent from -20 to 0 in y, which is beyond the original y range.\n\n# Initial conditions\nstateinit = let\n   x0 = [0.0, 0.0, 0.0] # initial position [l₀]\n   u0 = [10.0, 0.0, 0.0] # initial velocity [v₀]\n   [x0..., u0...]\nend\n# Time span\ntspan = (0.0, 1.5π) # 3/4 gyroperiod\n\nprob = ODEProblem(trace_normalized!, stateinit, tspan, param)\nsol = solve(prob, Vern9());\n\nVisualization\n\nf = Figure(fontsize = 18)\nax = Axis(f[1, 1],\n   title = \"Proton trajectory\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   limits = (-10.1, 10.1, -20.1, 0.1),\n   aspect = DataAspect()\n)\n\nlines!(ax, sol, idxs = (1, 2))\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_proton_dipole/#demo_dipole","page":"Magnetic dipole","title":"Magnetic dipole","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace protons of a certain energy in a analytic Earth-like magnetic dipole field. There is a combination of grad-B drift, curvature drift, and the bounce motion between mirror points. It demonstrates the motions corresponding to the three adiabatic invariants.\n\nusing TestParticle, OrdinaryDiffEq\nimport TestParticle as TP\nusing TestParticle: mᵢ, qᵢ, c, Rₑ\nusing CairoMakie\n\n# Initial condition\nstateinit = let\n   # Initial particle energy\n   Ek = 5e7 # [eV]\n   # initial velocity, [m/s]\n   v₀ = TP.sph2cart(c*sqrt(1-1/(1+Ek*qᵢ/(mᵢ*c^2))^2), π/4, 0.0)\n   # initial position, [m]\n   r₀ = TP.sph2cart(2.5*Rₑ, π/2, 0.0)\n   [r₀..., v₀...]\nend\n# obtain field\nparam = prepare(TP.getE_dipole, TP.getB_dipole)\ntspan = (0.0, 10.0)\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\n\nsol = solve(prob, Vern9())\n\n### Visualization\n\nf = Figure(fontsize = 18)\n##ax = Axis3(f[1, 1],\n#   title = \"50 MeV Proton trajectory in Earth's dipole field\",\n#   xlabel = \"x [Re]\",\n#   ylabel = \"y [Re]\",\n#   zlabel = \"z [Re]\",\n#   aspect = :data,\n#   limits = (-2.5, 2.5, -2.5, 2.5, -1, 1)\n##)\nax = LScene(f[1, 1])\ninvRE = 1 / Rₑ\n\nl = lines!(ax, sol, idxs = (1, 2, 3))\n# In Makie 0.21.11, scene scaling has no effect on Axis3.\nscale!(ax.scene, invRE, invRE, invRE)\n\nfor ϕ in range(0, stop = 2*π, length = 10)\n   lines!(TP.dipole_fieldline(ϕ) .* Rₑ..., color = :tomato, alpha = 0.3)\nend\n\n\n(Image: )\n\nSolver algorithm matters in terms of energy conservation. In the above we used Verner's “Most Efficient” 9/8 Runge-Kutta method. Let's check other algorithms.\n\nfunction get_energy_ratio(sol)\n   vx = @view sol[4, :]\n   vy = @view sol[5, :]\n   vz = @view sol[6, :]\n\n   Einit = vx[1]^2 + vy[1]^2 + vz[1]^2\n   Eend = vx[end]^2 + vy[end]^2 + vz[end]^2\n\n   (Eend - Einit) / Einit\nend\n\n# `ImplicitMidpoint()` requires a fixed time step.\nsol = solve(prob, ImplicitMidpoint(); dt = 1e-3)\nget_energy_ratio(sol)\n\n-0.0004598227659719038\n\nsol = solve(prob, ImplicitMidpoint(); dt = 1e-4)\nget_energy_ratio(sol)\n\n-4.940099606037697e-9\n\nsol = solve(prob, Vern9())\nget_energy_ratio(sol)\n\n-0.007077933489657505\n\nsol = solve(prob, Trapezoid())\nget_energy_ratio(sol)\n\n-0.05513894687213265\n\nsol = solve(prob, Vern6())\nget_energy_ratio(sol)\n\n-0.06578126499744592\n\nsol = solve(prob, Tsit5())\nget_energy_ratio(sol)\n\n0.5352006159583219\n\nDefault stepsize settings may not be enough for our problem. By using a smaller abstol and reltol, we can guarantee much better conservation at a higher cost:\n\n# This is roughly equivalent in accuracy and performance with Vern9() and `reltol=1e-3` (default)\nsol = solve(prob, Tsit5(); reltol = 1e-4);\n\nOr, for adaptive time step algorithms like Vern9(), with the help of callbacks, we can enforce a largest time step smaller than 1/10 of the local gyroperiod:\n\nusing DiffEqCallbacks\n\n# p = (charge_mass_ratio, m, E, B)\ndtFE(u, p, t) = 2π / (abs(p[1]) * sqrt(sum(x -> x^2, p[4](u, t))))\n\ncb = StepsizeLimiter(dtFE; safety_factor = 1 // 10, max_step = true)\n\nsol = solve(prob, Vern9(); callback = cb, dt = 0.1) # dt=0.1 is a dummy value\nget_energy_ratio(sol)\n\n-5.399366759077119e-7\n\nThis is much more accurate, at the cost of more iterations. In terms of accuracy, this is roughly equivalent to solve(prob, Vern9(); reltol=1e-7); in terms of performance, it is 2x slower (0.04s v.s. 0.02s) and consumes about the same amount of memory 42 MiB. We can also use the classical Boris method implemented within the package:\n\ndt = 1e-4\nprob = TraceProblem(stateinit, tspan, param)\nsol = TestParticle.solve(prob; dt)[1]\nget_energy_ratio(sol)\n\n6.65946423755708e-15\n\nThe Boris method requires a fixed time step. It takes about 0.05s and consumes 53 MiB memory. In this specific case, the time step is determined empirically. If we increase the time step to 1e-2 seconds, the trajectory becomes completely off (but the energy is still conserved). Therefore, as a rule of thumb, we should not use the default Tsit5() scheme without decreasing reltol. Use adaptive Vern9() for an unfamiliar field configuration, then switch to more accurate schemes if needed. A more thorough test can be found here.\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_cosmicray/#demo_cosmic_ray","page":"Cosmic Ray Tracing","title":"Cosmic Ray Tracing","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace cosmic rays in a background magnetic field. In the original MHD solution, everything is dimensionless. We are following the normalization procedures in Cosmic ray propagation in sub-Alfvénic magnetohydrodynamic turbulence. The Lorentz equation for each particle of charge q and mass m. The particle has a momentum mathbfp = gamma m mathbfv and a velocity mathbfv and propagates in an electromagnetic field mathbfE (no mean electric field), mathbfB = delta mathbfB + mathbfB_0:\n\nbeginaligned\nfracmathrmdmathbfpmathrmd t = q (mathbfE + fracmathbfvc times mathbfB) \nfracmathrmdmathbfxmathrmd t = mathbfv\nendaligned\n\nEach particle is injected with a Lorentz factor gamma_0. Physically, one can think of gamma_0 as a measure of the relativity of the particle, i.e., for small gamma_0 we will recover nonrelativistic equations, and for large gamma_0 –- ultra-relativistic equations. gamma_0 also defines the initial Larmor radius\n\nr_L0 = gamma_0 m c^2  (e B_0)\n\nwhere B_0 is background magnetic field strength. We also define the particle's synchrotron pulsation\n\nOmega_0 = c  r_L0\n\nThis is measured in cyclotron frequency units, a gyration frequency measured in the particle's own frame. A particle with pitch angle cosine mu = costheta = 0 will make a full orbit in the B_0 field in 2 pi time. After normalization, we have\n\nbeginaligned\nfracmathrmdmathbfv^primemathrmd t^prime = gamma^prime mathbfE^prime + mathbfv^prime times mathbfB^prime \nfracmathrmdmathbfx^primemathrmd t^prime = fracr_L 0L mathbfv^prime\nendaligned\n\nwhere gamma^prime = gamma  gamma_0, mathbfv^prime = gamma^prime mathbfvc, and t^prime = t  (gamma^prime r_L0c), mathbfE^prime = mathbfE  (B_0) is the normalized electric field, mathbfB^prime = mathbfB  B_0 is the normalized magnetic field, and x^prime = x  L. L is the length scale we can choose to decide how many discrete point to have within one gyroradius. For instance, if L = r_L 0, then 1 unit distance in the dimensionless system is 1 gyroradius for a particle with gamma_0 under B_0; if L = 4 r_L 0, then 1 unit distance in the dimensionless system is 4 gyroradii for a particle with gamma_0 under B_0. The smaller r_L0  L is, the more likely a particle will experience an inhomogeneous magnetic field during gyration, and the more likely it will get scattered. Note that gamma^prime is also a function of mathbfv:\n\ngamma^prime = gamma  gamma_0 =  sqrtfrac1 - v_0^2c^21 - v^2c^2\n\nIn practice, at least in the interstellar medium, the effect of the electric field over high-energy (multi TeV) cosmic rays can be neglected. Therefore, energy is conserved and we are interested in looking at the scattering and diffusion processes. gamma^prime = 1 without considering radiative loss or re-acceleration.\n\nThus, the normalized equations can be further simplified:\n\nbeginaligned\nfracmathrmdmathbfv^primemathrmd t^prime = mathbfv^prime times mathbfB^prime \nfracmathrmdmathbfx^primemathrmd t^prime = fracr_L 0L mathbfv^prime\nendaligned\n\nBy taking q=1 m=1 c=1 B_0=1, the characteristic length and frequency scales are\n\nbeginaligned\nr_L0 = fracgamma_0 m c^2e B_0 = gamma_0 \nOmega_0 = frace B_0m c^2 = 1\nendaligned\n\nThis looks good, but there is still an annoying factor r_L 0  L in the second equation. We can remove that by combining L  r_L 0 with mathbfx:\n\nfracmathrmdmathbfx^primemathrmd t^prime = mathbfv^prime\n\nIt simply means that if the original domain length is 1, now it becomes L  r_L 0.\n\nA standard procedure is as follows:\n\nObtain the dimensionless MHD solution.\nNormalize the magnetic field with its background mean magnitude, such that in the new field, B_0 = 1. This has a clear physical meaning that a particle with velocity 1 has a gyroradii of 1 and a gyroperiod of  2pi.\nManually choose the spatial extent to be Lr_L 0. For simplicity, we set r_L0=1 and the MHD domain extent to be -L2 L2. If we have nx discrete points along that direction, then the grid size is dx = L  nx. If L = nx4, then dx = 14 is a quarter of the gyroradius. In this way we can control how well we resolve the magnetic field for the gyromotion and diffusion process.\n\nNow let's demonstrate this with trace_normalized!.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing CairoMakie\n\n# Number of cells for the field along each dimension\nnx, ny, nz = 4, 6, 2\n# Unit conversion factors for length\nrL0 = 1.0\nL = nx / 4\n# Set length scales\nx = range(-L/2-1e-2, L/2+1e-2, length = nx) # [rL0]\ny = range(-L-1e-2, 1e-2, length = ny) # [rL0]\nz = range(-10, 10, length = nz) # [rL0]\n\nB = fill(0.0, 3, nx, ny, nz) # [B0]\nB[3, :, :, :] .= 1.0\nE(x) = SA[0.0, 0.0, 0.0] # [E₀]\n# periodic bc = 2\nparam = prepare(x, y, z, E, B; species = User, bc = 2)\n\n# Initial condition\nstateinit = let\n   x0 = [0.0, 0.0, 0.0] # initial position [l₀]\n   u0 = [1.0, 0.0, 0.0] # initial velocity [v₀] -> r = 1 * rL0\n   [x0..., u0...]\nend\n# Time span\ntspan = (0.0, π) # half gyroperiod\n\nprob = ODEProblem(trace_normalized!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\n### Visualization\nf = Figure(fontsize = 18)\nax = Axis(f[1, 1],\n   title = \"Proton trajectory\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   limits = (2*x[1]-0.1, 2*x[end]+0.1, 2*y[1]-0.1, 2*y[end]+0.1),\n   aspect = DataAspect()\n)\n\nlines!(ax, sol, idxs = (1, 2))\n\nxgrid = [i for i in x, _ in y]\nygrid = [j for _ in x, j in y]\nscatter!(ax, xgrid[:], ygrid[:], color = :tomato)\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_gpu/#demo_gpu_ensemble","page":"GPU Ensemble tracing","title":"GPU Ensemble tracing","text":"(Image: Author) (Image: Update time)\n\nThis example demonstrates the usage of GPU for ensemble tracing. Since GitHub Actions do not have GPU runners for now, we do not show the results on page.\n\nusing TestParticle\nusing DiffEqGPU, OrdinaryDiffEq, CUDA, StaticArrays\nusing CairoMakie\n\n\"Set initial state for EnsembleProblem.\"\nfunction prob_func(prob, i, repeat)\n   prob = @views remake(prob, u0=[prob.u0[1:3]..., i/3, 0.0, 0.0])\nend\n\n## Initialization\n\nB(x) = SA[0, 0, 1e-11]\nE(x) = SA[0, 0, 1e-13]\n\nx0 = [0.0, 0.0, 0.0] # initial position, [m]\nu0 = [1.0, 0.0, 0.0] # initial velocity, [m/s]\nstateinit = [x0..., u0...]\n\nparam = prepare(E, B, species=Electron)\ntspan = (0.0, 10.0)\n\ntrajectories = 3\n\n## Solve for the trajectories\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nensemble_prob = EnsembleProblem(prob; prob_func, safetycopy=false)\nsols = solve(ensemble_prob, Tsit5(), EnsembleGPUArray(CUDA.CUDABackend()); trajectories)\n\n## Visualization\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Electron trajectories\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   zlabel = \"Z\",\n   aspect = :data,\n)\n\nfor i in eachindex(sols)\n   lines!(ax, sols[i], idxs=(1,2,3), label=\"$i\", color=Makie.wong_colors()[i])\nend\n\nf\n\nWhile EnsembleGPUArray has a bit of overhead due to its form of GPU code construction, EnsembleGPUKernel is a more restrictive GPU-itizing algorithm that achieves a much lower overhead in kernel launching costs. However, it requires this problem to be written in out-of-place form and use special solvers. Additionally, a timestep dt or saveat keyword is required for dense outputs.\n\nusing TestParticle\nusing DiffEqGPU, OrdinaryDiffEq, CUDA, StaticArrays\nusing CairoMakie\n\n\"Set initial state for EnsembleProblem.\"\nfunction prob_func(prob, i, repeat)\n   prob = @views remake(prob, u0=SA[prob.u0[1:3]..., i/3, 0.0, 0.0])\nend\n\n## Initialization\n\nB(x) = SA[0, 0, 1e-11]\nE(x) = SA[0, 0, 1e-13]\n\nx0 = SA[0.0, 0.0, 0.0] # initial position, [m]\nu0 = SA[1.0, 0.0, 0.0] # initial velocity, [m/s]\nstateinit = SA[x0..., u0...]\n\nparam = prepare(E, B, species=Electron)\ntspan = (0.0, 10.0)\n\ntrajectories = 3\n\n## Solve for the trajectories\n\nprob = ODEProblem(trace, stateinit, tspan, param)\nensemble_prob = EnsembleProblem(prob; prob_func, safetycopy=false)\n## saving time interval is required for dense output! \nsols = solve(ensemble_prob, GPUTsit5(), EnsembleGPUKernel(CUDA.CUDABackend());\n   trajectories, saveat=0.4)\n\n## Visualization\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Electron trajectories\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   zlabel = \"Z\",\n   aspect = :data,\n)\n\nfor i in eachindex(sols)\n   lines!(ax, sols[i], idxs=(1,2,3), label=\"$i\", color=Makie.wong_colors()[i])\nend\n\nf\n\n\n\nThis page was generated using DemoCards.jl.","category":"section"},{"location":"examples/advanced/demo_shock/#demo_shock","page":"Shock","title":"Shock","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace protons of a certain energy in MHD plane shocks.\n\nusing TestParticle, OrdinaryDiffEqVerner\nusing TestParticle: mᵢ, kB\nusing LinearAlgebra\nusing Statistics: mean, std\nusing Printf\nusing Random\nusing CairoMakie, PairPlots\n\n# For reproducible results\nRandom.seed!(1234)\n\n\"\"\"\nSet initial conditions.\n\"\"\"\nfunction prob_func(prob, i, repeat)\n   v₀ = sample(vdf₁)\n   r₀ = [5_000e3, 0.0, 0.0]\n\n   prob = remake(prob; u0 = [r₀..., v₀...])\nend;\n\nPerpendicular shock is a special shock in which both the upstream and downstream plasma flows are perpendicular to the magnetic field, as well as the shock front.\n\n# MHD states in SI units\nn₁ = 1.0e6\nT₁ = 720471.8506664868\nPi₁ = 0.0049735919716217296 * 1e-9\nPe₁ = 0.0049735919716217296 * 1e-9\nPth₁ = Pi₁ + Pe₁\nV₁ = [-545.1484121835928, 0.0, 0.0] .* 1e3\nB₁ = [0.0, 0.0, 5.0] .* 1e-9\n\nn₂ = 3.1662479035540008e6\nT₂ = 5.957947703036288e6\nPi₂ = 0.13022511153415584 * 1e-9\nPe₂ = 0.13022511153415584 * 1e-9\nPth₂ = Pi₂ + Pe₂\nV₂ = [-172.17489874108816, 0.0, 0.0] .* 1e3\nB₂ = [0.0, 0.0, 15.831239517770003] .* 1e-9;\n\nIn ideal MHD, the electric field simply contains the convection term. For perpendicular shocks, the electric field across the shock is continuous. In the upstream, particles follow straight lines because it's purely an ExB drift; across the shock, ExB drift changes to the downstream bulk velocity.\n\nE₁ = B₁ × V₁\nE₂ = B₂ × V₂\n\n# Shock normal direction range\nx = range(-5_000e3, 5_000e3, length = 100)\nB = repeat(B₁, 1, length(x))\nE = repeat(E₁, 1, length(x))\n# Index for the shock location\nmid_ = length(x) ÷ 2\n\nB[:, 1:mid_] .= B₂\nE[:, 1:mid_] .= E₂\n\nconst vdf₁ = Maxwellian(V₁, Pth₁, n₁; m = mᵢ)\nvdf₂ = Maxwellian(V₂, Pth₂, n₂; m = mᵢ)\n\ntrajectories = 400\nweight₁ = n₁ / trajectories # relation between test particle and real particles\n\nprob = let\n   # BC type 3 is Flat\n   param = prepare(x, E, B; species = Proton, bc = 3);\n   stateinit = zeros(6) # particle position and velocity to be modified\n   tspan = (0.0, 30.0)\n   ODEProblem(trace!, stateinit, tspan, param)\nend\nensemble_prob = EnsembleProblem(prob; prob_func, safetycopy = false)\n\nsols = solve(ensemble_prob, Vern9(), EnsembleSerial(); trajectories);\n\nSample particle trajectories\n\nfunction plot_traj(sols; azimuth = 1.275pi, elevation = pi/8,\n      limits = ((-4000.0, 4000.0), (-1000.0, 1000.0), (-2000.0, 2000.0)))\n   f = Figure(fontsize = 18)\n   ##ax = Axis3(f[1, 1];\n   #   title=\"Particles across MHD shock\",\n   #   xlabel=\"x [km]\",\n   #   ylabel=\"y [km]\",\n   #   zlabel=\"z [km]\",\n   #   aspect=:data,\n   #   limits, azimuth, elevation,\n   ##)\n   ax = LScene(f[1, 1], show_axis = true)\n   for i in eachindex(sols)\n      lines!(ax, sols[i], idxs = (1, 2, 3), label = \"$i\",\n         color = Makie.wong_colors()[mod(i - 1, 7) + 1])\n   end\n   invL = 1 / 1e3\n   # In Makie 0.21.11, scene scaling has issues on Axis3.\n   ##scale!(ax.scene, invL, invL, invL)\n\n   # Represent the shock front\n   p1 = Point3f(0.0, -2e2, -2e2)\n   p2 = Point3f(0.0, 2e2, -2e2)\n   p3 = Point3f(0.0, 2e2, 2e2)\n   p4 = Point3f(0.0, -2e2, 2e2)\n\n   mesh!(ax, [p1, p2, p3], color = (:gray, 0.1), shading = Makie.automatic)\n   mesh!(ax, [p1, p4, p3], color = (:gray, 0.1), shading = Makie.automatic)\n\n   f\nend\n\nf = plot_traj(sols[1:4])\n\n(Image: )\n\nPhase space distributions\n\nfunction plot_dist(x, sols; nxchunks::Int = 2, ntchunks::Int = 20)\n   trange = range(sols[1].prob.tspan..., length = ntchunks)\n\n   xrange = range(x[1], x[end], length = nxchunks+1)\n   dx = (x[end] - x[1]) / nxchunks\n   xmid = range(x[1] + 0.5dx, x[end] - 0.5dx, length = nxchunks) ./ 1e3\n\n   vx = [Float64[] for _ in 1:nxchunks]\n\n   for sol in sols\n      for t in trange\n         xv = sol(t)\n         for i in 1:nxchunks\n            if xrange[i] < xv[1] ≤ xrange[i + 1]\n               push!(vx[i], xv[4] / 1e3)\n            end\n         end\n      end\n   end\n\n   for i in eachindex(vx)\n      if isempty(vx[i])\n         push!(vx[i], 0.0)\n      end\n   end\n\n   f = Figure(size = (1200, 600), fontsize = 18)\n   ax = Axis(f[1, 1],\n      limits = (nothing, nothing, -750, 400),\n      title = \"Phase space distributions at different spatial locations\",\n      xlabel = \"Location [km]\",\n      ylabel = \"Vx [km/s]\",\n      xminorticksvisible = true)\n\n   for i in 1:nxchunks\n      hist!(ax, vx[i], normalization = :pdf, bins = 50,\n         scale_to = -5000/nxchunks, offset = xmid[i], direction = :x)\n   end\n\n   v̄x = mean.(vx)\n   vth = [std(vx[i]; corrected = false, mean = v̄x[i]) for i in 1:nxchunks]\n   means_str = [@sprintf \"Vx: %d [km/s]\" v̄x[i] for i in eachindex(v̄x)]\n   std_str = [@sprintf \"Vth: %d [km/s]\" vth[i] for i in eachindex(vth)]\n   text!(Point.(xmid .+ 400, 300.0), text = means_str, align = (:right, :center),\n      offset = (-60, 0), color = :black, fontsize = 24)\n   text!(Point.(xmid .+ 400, -700.0), text = std_str, align = (:right, :center),\n      offset = (-60, 0), color = :black, fontsize = 24)\n\n   f\nend\n\nf = plot_dist(x, sols; nxchunks = 4, ntchunks = 100)\n\n(Image: )\n\nEven with 400 particles, we are still able to statistically approximate the velocity moment downstream of the perpendicular shock. While the upstream thermal speed is close to what we set, the downstream thermal speed is higher than our set value:\n\nVth₁ = 77.1 km/s\nVth₂ = 221.7 km/s\n\n\nA nice way to present the 3d distributions in 2d is via the pair plots:\n\nfunction collect_VDF(x, sols; ntchunks::Int = 20)\n   nxchunks = 2\n   trange = range(sols[1].prob.tspan..., length = ntchunks)\n\n   xrange = range(x[1], x[end], length = nxchunks+1)\n\n   table = [(;\n               vx = Float64[],\n               vy = Float64[],\n               vz = Float64[]\n            ) for _ in 1:nxchunks]\n\n   for sol in sols\n      for t in trange\n         xv = sol(t)\n         for i in 1:nxchunks\n            if xrange[i] < xv[1] ≤ xrange[i + 1]\n               push!(table[i].vx, xv[4] / 1e3)\n               push!(table[i].vy, xv[5] / 1e3)\n               push!(table[i].vz, xv[6] / 1e3)\n            end\n         end\n      end\n   end\n\n   for i in eachindex(table)\n      if isempty(table[i].vx)\n         push!(table[i].vx, 0.0)\n         push!(table[i].vy, 0.0)\n         push!(table[i].vz, 0.0)\n      end\n   end\n\n   xrange, table\nend\n\nfunction plot_dist_pairplots(x, sols; ntchunks::Int = 20)\n   xrange, table = collect_VDF(x, sols; ntchunks)\n\n   f = Figure(size = (1000, 600), fontsize = 18)\n\n   c1 = Makie.wong_colors(0.5)[1]\n   c2 = Makie.wong_colors(0.5)[2]\n\n   l1 = @sprintf \"x: [%d, %d] km downstream\" xrange[1]/1e3 xrange[2]/1e3\n   l2 = @sprintf \"x: [%d, %d] km upstream\" xrange[2]/1e3 xrange[3]/1e3\n\n   pairplot(f[1, 1],\n      PairPlots.Series(table[1], label = l1, color = c1),\n      PairPlots.Series(table[2], label = l2, color = c2),\n      PairPlots.Truth(\n         (;\n            vx = [-545.1484121835928, -172.1748987410881],\n            vy = 0,\n            vz = 0\n         ),\n         label = \"Bulk velocity\",\n         color = :brown\n      ),\n      bodyaxis = (; xgridvisible = true, ygridvisible = true),\n      diagaxis = (; xgridvisible = true, ygridvisible = true)\n   )\n\n   f\nend\n\nfunction plot_dist_pairplot(x, sols; ntchunks::Int = 20)\n   xrange, table = collect_VDF(x, sols; ntchunks)\n\n   f = Figure(size = (1000, 1200), fontsize = 18)\n\n   c1 = Makie.wong_colors(0.5)[1]\n   c2 = Makie.wong_colors(0.5)[2]\n\n   pairplot(f[1, 1],\n      PairPlots.Series(table[1], color = c1),\n      PairPlots.Truth(\n         (;\n            vx = -172.1748987410881,\n            vy = 0,\n            vz = 0\n         ),\n         color = :brown\n      )\n   )\n\n   pairplot(f[2, 1],\n      PairPlots.Series(table[2], color = c2),\n      PairPlots.Truth(\n         (;\n            vx = -545.1484121835928,\n            vy = 0,\n            vz = 0\n         ),\n         color = :brown\n      )\n   )\n\n   f\nend\n\nf = plot_dist_pairplots(x, sols; ntchunks = 20)\n\n(Image: )\n\nDownstream and upstream distributions showing separately:\n\nf = plot_dist_pairplot(x, sols; ntchunks = 20)\n\n(Image: )\n\nWe see that the upstream thermal speed is about what we set in all three dimensions, whereas the downstream thermal speed in the perpendicular plane is larger than the downstream isotropic thermal speed, and that in the parallel z direction is the same as the upstream thermal speed. This simply indicates that there is no heating across the shock in the parallel direction and more heating in the perpendicular directions, which in turn creates anisotropy  T_perp  T_parallel  1. Due to the lack of wave-particle interactions, there is no way to isotropize the test particle distributions in the downstream.\n\nFor parallel shocks, we have a different scenario. Parallel shock is another special shock in which both the upstream and downstream plasma flows are parallel to the magnetic field, as well as perpendicular to the shock front.\n\n# MHD states in SI units\nn₁ = 1.0e6\nT₁ = 720471.8506664868\nPi₁ = 0.0049735919716217296 * 1e-9\nPe₁ = 0.0049735919716217296 * 1e-9\nPth₁ = Pi₁ + Pe₁\nV₁ = [-545.1484121835928, 0.0, 0.0] .* 1e3\nB₁ = [5.0, 0.0, 0.0] .* 1e-9\n\nn₂ = 3.6363636363636362e6\nT₂ = 7.380333520264822e6\nPi₂ = 0.18526630094290936 * 1e-9\nPe₂ = 0.18526630094290936 * 1e-9\nPth₂ = Pi₂ + Pe₂\nV₂ = [-149.91581335048804, 0.0, 0.0] .* 1e3\nB₂ = [5.0, 0.0, 0.0] .* 1e-9;\n\nThere is no convection electric field in the parallel shock:\n\nE₁ = B₁ × V₁\nE₂ = B₂ × V₂\n\n3-element Vector{Float64}:\n  0.0\n -0.0\n  0.0\n\nTherefore, when we trace particles, there is no deceleration across the shock:\n\n# Shock normal direction range\nx = range(-5_000e3, 5_000e3, length = 100)\nB = repeat(B₁, 1, length(x))\nE = repeat(E₁, 1, length(x))\n# Index for the shock location\nmid_ = length(x) ÷ 2\n\nB[:, 1:mid_] .= B₂\nE[:, 1:mid_] .= E₂\n\nconst vdf₁ = Maxwellian(V₁, Pth₁, n₁; m = mᵢ)\nvdf₂ = Maxwellian(V₂, Pth₂, n₂; m = mᵢ)\n\ntrajectories = 2\nweight₁ = n₁ / trajectories\n\nprob = let\n   # BC type 3 is Flat\n   param = prepare(x, E, B; species = Proton, bc = 3);\n   stateinit = zeros(6) # particle position and velocity to be modified\n   tspan = (0.0, 14.0)\n   ODEProblem(trace!, stateinit, tspan, param)\nend\nensemble_prob = EnsembleProblem(prob; prob_func, safetycopy = false)\n\nsols = solve(ensemble_prob, Vern9(), EnsembleSerial(); trajectories);\n\nf = plot_traj(sols; azimuth = 1.08π, elevation = pi/16)\n\n(Image: )\n\nClearly, test particle tracing in MHD parallel shocks fails to recover physics. MHD parallel shocks are essentially hydrodynamic shocks where magnetic field plays no role. Due to the lack of collision and other diffusion processes, we are unable to capture the correct microscopic scenario here.\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_curvature_B/#demo_curlB","page":"Curl-B drift","title":"Curl-B drift","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates a single proton motion under a vacuum non-uniform B field with gradient and curvature. The analytic calculation includes the grad-B drift, the curvature drift, the ExB drift and parallel velocity. More theoretical details can be found in Curvature Drift and Computational Plasma Physics by Toshi Tajima.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing LinearAlgebra: normalize, norm, ×, ⋅\nusing ForwardDiff: gradient, jacobian\nusing CairoMakie\n\nfunction curved_B(x)\n   # satisify ∇⋅B=0\n   # B_θ = 1/r => ∂B_θ/∂θ = 0\n   θ = atan(x[3] / (x[1] + 3))\n   r = sqrt((x[1] + 3)^2 + x[3]^2)\n   return SA[-1e-7 * sin(θ) / r, 0, 1e-7 * cos(θ) / r]\nend\n\nzero_E(x) = SA[0, 0, 0]\n\nabs_B(x) = norm(curved_B(x))  # |B|\n\n# Initial conditions\nstateinit = let x0 = [1.0, 0.0, 0.0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 40)\n# Trace particle\nparam = prepare(zero_E, curved_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n# Functions for obtaining the guiding center from actual trajectory\ngc = param |> get_gc_func\ngc_x0 = gc(stateinit) |> Vector\nprob_gc = ODEProblem(trace_gc_drifts!, gc_x0, tspan, (param..., sol))\nsol_gc = solve(prob_gc, Vern7(); save_idxs = [1, 2, 3])\n\n# Numeric and analytic results\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Curvature Drift\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data,\n   azimuth = 0.3π\n)\n\ngc_plot(x, y, z, vx, vy, vz) = (gc(SA[x, y, z, vx, vy, vz])...,)\n\nlines!(ax, sol, idxs = (1, 2, 3), color = Makie.wong_colors()[1])\nlines!(ax, sol, idxs = (gc_plot, 1, 2, 3, 4, 5, 6), color = Makie.wong_colors()[2])\nlines!(ax, sol_gc, idxs = (1, 2, 3), color = Makie.wong_colors()[3])\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_multiple/#demo_multiple","page":"Multiple particles","title":"Multiple particles","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nusing TestParticle, OrdinaryDiffEqVerner\nusing Random\nusing CairoMakie\n\n# For reproducible results\nRandom.seed!(1234)\n\nfunction trace(x, y, z, E, B; trajectories::Int = 10)\n   # Initialize particles\n   x0 = [0.0, 0.0, 0.0] # initial position, [m]\n   u0 = [1.0, 0.0, 0.0] # initial velocity, [m/s]\n   stateinit = [x0..., u0...]\n\n   param = prepare(x, y, z, E, B, species = Electron)\n   tspan = (0.0, 15.0)\n\n   prob = ODEProblem(trace!, stateinit, tspan, param)\n\n   sols = Vector{ODESolution}(undef, trajectories)\n   # Sample from a Maxwellian with bulk speed 0 and thermal speed 1.0\n   vdf = Maxwellian([0.0, 0.0, 0.0], 1.0)\n   v = [sample(vdf) for _ in 1:trajectories]\n\n   for i in 1:trajectories\n      #prob = remake(prob; u0=[x0..., v[:,i]...])\n      prob.u0[4:6] = v[i]\n\n      sol = solve(prob, Vern9())\n      sols[i] = sol\n   end\n\n   return sols\nend\n\n### Initialize grid and field\nx = range(-10, 10, length = 15)\ny = range(-10, 10, length = 20)\nz = range(-10, 10, length = 25)\n\nB = fill(0.0, 3, length(x), length(y), length(z)) # [T]\nE = fill(0.0, 3, length(x), length(y), length(z)) # [V/m]\nB[3, :, :, :] .= 1e-11\nE[3, :, :, :] .= 5e-13\n\ntrajectories = 4\n\n### Solve for the trajectories\n\nsols = trace(x, y, z, E, B; trajectories)\n\n### Visualization\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Particle trajectories\",\n   xlabel = \"X [m]\",\n   ylabel = \"Y [m]\",\n   zlabel = \"Z [m]\",\n   aspect = :data\n)\n\nfor i in eachindex(sols)\n   lines!(ax, sols[i], idxs = (1, 2, 3), color = Makie.wong_colors()[i], label = \"$i\")\nend\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/basics/demo_ExB_drift/#demo_ExB","page":"E×B drift","title":"E×B drift","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Author) (Image: Update time)\n\nThis example demonstrates a single proton motion under uniform E and B fields. The electric field is parallel to the magnetic field in the z-direction, so the motion consists of a cyclotron gyration and an acceleration along z. On top of that, particles also exhibit an ExB drift in the direction perpendicular to both E and B field. More theoretical details can be found in ExB Drift.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing LinearAlgebra: ⋅, ×, normalize\nusing TestParticle: get_EField, get_BField\nusing CairoMakie\n\n# Analytic EM fields\nuniform_B(x) = SA[0, 0, 1e-8]\nuniform_E(x) = SA[1e-9, 0, 0]\n\n# Trace the orbit of the guiding center\nfunction trace_gc_ExB!(dx, x, p, t)\n   sol = p[end]\n   Bfunc = get_BField(p)\n   Efunc = get_EField(p)\n   xu = sol(t)\n   Bv = Bfunc(x)\n   b = normalize(Bv)\n   v_par = @views (xu[4:6] ⋅ b) .* b\n   B2 = sum(Bv .^ 2)\n   dx[1:3] = (Efunc(x) × Bv) / B2 + v_par\nend\n# Initial condition\nstateinit = let x0 = [1.0, 0.0, 0.0], v0 = [0.0, 1.0, 0.1]\n   [x0..., v0...]\nend\n# Time span\ntspan = (0, 20)\n\n# Trace particle\nparam = prepare(uniform_E, uniform_B, species = Proton)\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern9())\n\n# Functions for obtaining the guiding center from actual trajectory\ngc = param |> get_gc_func\ngc_x0 = gc(stateinit) |> Vector\nprob_gc = ODEProblem(trace_gc_ExB!, gc_x0, tspan, (param..., sol))\nsol_gc = solve(prob_gc, Vern9(); save_idxs = [1, 2, 3]);\n\n# Numeric and analytic results\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"ExB Drift\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data,\n   azimuth = 0.3π\n)\n\ngc_plot(x, y, z, vx, vy, vz) = (gc(SA[x, y, z, vx, vy, vz])...,)\n\nlines!(ax, sol, idxs = (1, 2, 3), color = Makie.wong_colors()[1])\nlines!(ax, sol, idxs = (gc_plot, 1, 2, 3, 4, 5, 6), color = Makie.wong_colors()[2])\nlines!(ax, sol_gc, idxs = (1, 2, 3), linestyle = :dash, color = Makie.wong_colors()[3])\n\n\n(Image: )\n\nNote that in this simple ExB drift case, the analytic and numeric guiding centers overlaps. Also note that trace_gc_ExB! here depends on the velocity at time t from the particle trajectory, which is not exactly the guiding center velocity. A first-order GC approximation tracker would be the following:\n\nstateinit_gc,\nparam_gc = prepare_gc(stateinit, uniform_E, uniform_B, species = Proton, removeExB = false)\nprob_gc1st = ODEProblem(trace_gc_1st!, stateinit_gc, tspan, param_gc)\nsol_gc1st = solve(prob_gc1st, Vern9())\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"ExB Drift\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data,\n   azimuth = 0.3π\n)\n\nlines!(ax, sol, idxs = (1, 2, 3), color = Makie.wong_colors()[1])\nlines!(ax, sol_gc1st, idxs = (1, 2, 3), linestyle = :dash, color = Makie.wong_colors()[3])\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_boris_outofdomain/#demo_boris_advance","page":"Advanced Boris tracing","title":"Advanced Boris tracing","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace charged particles using the Boris method in dimensionless units with additionally boundary check. If the particles travel out of the domain specified by the field, the tracing will stop. Check Demo: Dimensionless Units for explaining the unit conversion, and Demo: Boris Method for introducing the Boris method.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing TestParticle: qᵢ, mᵢ\nusing CairoMakie\n\n\"\"\"\nSet initial states.\n\"\"\"\nfunction prob_func(prob, i, repeat)\n   prob = @views remake(prob; u0 = [prob.u0[1:3]..., 10.0 - i*2.0, prob.u0[5:6]...])\nend\n\nisoutofdomain(xv, p, t) =\n   if isnan(xv[1])\n      return true\n   else\n      return false\n   end\n\n# Number of cells for the field along each dimension\nnx, ny = 4, 6\n# Unit conversion factors between SI and dimensionless units\nB₀ = 10e-9            # [T]\nΩ = abs(qᵢ) * B₀ / mᵢ # [1/s]\nt₀ = 1 / Ω            # [s]\nU₀ = 1.0              # [m/s]\nl₀ = U₀ * t₀          # [m]\nE₀ = U₀*B₀            # [V/m]\n\nx = range(0, 11, length = nx) # [l₀]\ny = range(-21, 0, length = ny) # [l₀]\n\nB = fill(0.0, 3, nx, ny) # [B₀]\nB[3, :, :] .= 1.0\n\nE(x) = SA[0.0, 0.0, 0.0] # [E₀]\n\n# If bc == 1, we set a NaN value outside the domain (default);\n# If bc == 2, we set periodic boundary conditions.\nparam = prepare(x, y, E, B; species = User, bc = 1);\n\nNote that we set a radius of 10 - 2i, where i is the index of the particle. The trajectory domain extends from -20 to 0 in y, and -10 to 10 in x. After half a cycle, the particle will move into the region where is field is not defined. The tracing will stop with the final step being all NaNs.\n\n# Initial conditions to be modified in prob_func\nx0 = [0.0, 0.0, 0.0] # initial position [l₀]\nu0 = [0.0, 0.0, 0.0] # initial velocity [v₀], will be overwritten in prob_func\nstateinit = [x0..., u0...]\ntspan = (0.0, 1.5π) # 3/4 gyroperiod\n\ndt = 0.1\nsavestepinterval = 1\ntrajectories = 2\nprob = TraceProblem(stateinit, tspan, param; prob_func)\n\nsols = TestParticle.solve(prob; dt, savestepinterval, isoutofdomain, trajectories)\n\nf = Figure(fontsize = 18)\nax = Axis(f[1, 1],\n   title = \"Proton trajectory\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   limits = (-10.1, 10.1, -20.1, 0.1),\n   aspect = DataAspect()\n)\n\nfor i in eachindex(sols)\n   lines!(ax, sols[i]; idxs = (1, 2), label = string(i), color = Makie.wong_colors()[i])\nend\n\naxislegend(position = :lt, framevisible = false)\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_ensemble/#demo_ensemble","page":"Ensemble tracing","title":"Ensemble tracing","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example demonstrates tracing multiple electrons in an analytic EM field and how to take advantage of the multithreading support in the ODE solver. A multiproc version is also available. Check the official documentation of DifferentialEquations.jl for details. In performing test particle tracing, we want to share the field information for all particles. This can be achieved in the ensemble problem with safetycopy=false.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nusing CairoMakie\n\n\"\"\"\nSet initial state for EnsembleProblem.\n\"\"\"\nfunction prob_func(prob, i, repeat)\n   prob = @views remake(prob, u0 = [prob.u0[1:3]..., i/3, 0.0, 0.0])\nend\n\n# Initialization\n\nB(x) = SA[0, 0, 1e-11]\nE(x) = SA[0, 0, 1e-13]\n\nx0 = [0.0, 0.0, 0.0] # initial position, [m]\nu0 = [1.0, 0.0, 0.0] # initial velocity, [m/s]\nstateinit = [x0..., u0...]\n\nparam = prepare(E, B, species = Electron)\ntspan = (0.0, 10.0)\n\ntrajectories = 3\n\n# Solve for the trajectories\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nensemble_prob = EnsembleProblem(prob; prob_func, safetycopy = false)\nsols = solve(ensemble_prob, Vern7(), EnsembleThreads(); trajectories)\n\n# Visualization\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Electron trajectories\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   zlabel = \"Z\",\n   aspect = :data\n)\n\nfor i in eachindex(sols)\n   lines!(ax, sols[i], idxs = (1, 2, 3), label = \"$i\", color = Makie.wong_colors()[i])\nend\n\n\n(Image: )\n\nWe can also solve this problem with the native Boris pusher. Note that the Boris pusher requires a additional parameters: a fixed timestep, and an output save interval.\n\ndt = 0.1\nsavestepinterval = 1\n\n# Solve for the trajectories\n\nprob = TraceProblem(stateinit, tspan, param; prob_func)\ntrajs = TestParticle.solve(prob; dt, trajectories, savestepinterval)\n\n# Visualization\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Electron trajectories\",\n   xlabel = \"X\",\n   ylabel = \"Y\",\n   zlabel = \"Z\",\n   aspect = :data\n)\n\nfor i in eachindex(trajs)\n   lines!(ax, trajs[i]; idxs = (1, 2, 3), label = \"$i\", color = Makie.wong_colors()[i])\nend\n\n\n(Image: )\n\nNote that by default linear interpolation is applied when plotting the trajectories from the Boris method.\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"examples/advanced/demo_tokamak_profile/#demo_tokamak_profile","page":"Tokamak profile","title":"Tokamak profile","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace protons in a stationary magnetic field that corresponds to an ITER-like Tokamak.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nimport TestParticle as TP\nusing GeometryBasics\nusing CairoMakie\n\n# Parameters from ITER, see http://fusionwiki.ciemat.es/wiki/ITER\nconst R₀ = 6.2  # Major radius [m]\nconst Bζ0 = 5.3  # toroidal field on axis [T]\nconst a = 2.0 # Minor radius [m]\n\n# Variable must be a radius normalized by minor radius.\nq_profile(nr::Float64) = nr^2 + 2*nr + 0.5\n\nB(xu) = SVector{3}(TP.getB_tokamak_profile(xu[1], xu[2], xu[3], q_profile, a, R₀, Bζ0))\n\nE(xu) = SA[0.0, 0.0, 0.0]\n\n\"\"\"\nContruct the topology of Tokamak.\n\"\"\"\nfunction get_tokamak_topology()\n   nθ = LinRange(0, 2π, 30)\n   nζ = LinRange(0, 2π, 30)\n   nx = [R₀*cos(ζ) + a*cos(θ)*cos(ζ) for θ in nθ, ζ in nζ]\n   ny = [R₀*sin(ζ) + a*cos(θ)*sin(ζ) for θ in nθ, ζ in nζ]\n   nz = [a*sin(θ) for θ in nθ, ζ in nζ]\n   points = vec([Point3f(xv, yv, zv) for (xv, yv, zv) in zip(nx, ny, nz)])\n   faces = decompose(QuadFace{GLIndex}, Tesselation(Rect(0, 0, 1, 1), size(nz)))\n\n   tor_mesh = GeometryBasics.Mesh(points, faces)\nend\n\nMain.var\"##345\".get_tokamak_topology\n\nPassing proton in a Tokamak\n\n# initial velocity for passing particle\nv₀ = [0.0, 2.15, 3.1] .* 1e6\n# initial position, [m]. where q≈2, (2, 1) flux surface.\nr₀ = [7.3622, 0.0, 0.0]\nstateinit = [r₀..., v₀...]\n\nparam = prepare(E, B; species = Proton)\ntspan = (0.0, 4e-5) # [s]\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern7(); dt = 2e-11);\n\ntor_mesh = get_tokamak_topology()\n\nfig1 = Figure(fontsize = 18)\nax = Axis3(fig1[1, 1],\n   title = \"Passing Particle\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\n\nlines!(ax, sol; idxs = (1, 2, 3))\n# Plot the surface of Tokamak\nwireframe!(fig1[1, 1], tor_mesh, color = (:blue, 0.1), linewidth = 0.5, transparency = true)\n\n\n(Image: )\n\nTrapped proton in a Tokamak that shows the banana orbit\n\n# initial velocity for trapped particle\nv₀ = [0.0, 1.15, 5.1] .* 1e6\n# initial position, [m]. where q≈1, (1, 1) flux surface.\nr₀ = [6.6494, 0.0, 0.0]\nstateinit = [r₀..., v₀...]\n\nparam = prepare(E, B; species = Proton)\ntspan = (0.0, 4e-5)\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\nsol = solve(prob, Vern7(); dt = 1e-11)\n\nfig2 = Figure(fontsize = 18)\nax = Axis3(fig2[1, 1],\n   title = \"Trapped Particle\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\n\nlines!(ax, sol; idxs = (1, 2, 3))\nwireframe!(fig2[1, 1], tor_mesh, color = (:blue, 0.1), linewidth = 0.5, transparency = true)\n\n\n(Image: )\n\nThe trajectory of the trapped particle is sometimes called the \"banana orbit\".\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"},{"location":"#TestParticle.jl","page":"Home","title":"TestParticle.jl","text":"TestParticle.jl is a test particle tracer in a static electromagnetic field.\n\nThis package supports charged particle tracing in analytic/numerical relativistic/non-relativistic\n\nelectric and magnetic field;\nbody force field.\n\nAll tracing are performed in 3D, as is the nature for the fields. For a numerical field, the mesh is constructed with Meshes.jl, and the field is interpolated with the aid of Interpolations.jl. For an analytical field, the user is responsible for providing the function for calculating the field at a given spatial location. The actual tracing is done through DifferentialEquations.jl, thanks to the ODE system of the equations of motion.\n\nFor all the tracing methods, we provide both an inplace version (with ! at the end of the function name) and a non-inplace version using StaticArrays. The non-inplace version requires the initial conditions to be static a static vector. Use them at your convenience.\n\nThe single particle motions are the basics in understanding the test particle method. Check out Single-Particle Motions for more complete maths.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"julia> ]\npkg> add TestParticle","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"It would be better to understand the basic workflow of DifferentialEquations.jl before digging into TestParticle.jl. All we are doing here can be concluded as contructing the ODE system from Newton's 2nd law and preparing the field/particle data. Check more in examples.\n\nAdditionally, we have a native Boris solver with a similar interface as DifferentialEquations.jl. Check out the details in later sections.","category":"section"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"Nothing can be done such easily without the support of the Julia community. We appreciate all the contributions from developers around the world.","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"What makes plasmas particularly difficult to analyze is the fact that the densities fall in an intermediate range. Fluids like water are so dense that the motions of individual molecules do not have to be considered. Collisions dominate, and the simple equations of ordinary fluid dynamics suffice. At the other extreme in very low-density devices, only single-particle trajectories need to be considered; collective effects are often unimportant. Plasma behaves sometimes like fluids, and sometimes like a collection of individual particles. The first step in learning how to deal with this schizophrenic personality is to understand how single particles behave in electric and magnetic fields.\n\nHere we assume that the EM fields are prescribed and not affected by the charged particles. References can be found in classic textbooks like Introduction to Plasma Physics and Controlled Fusion by F.F.Chen, and Fundamentals of Plasma Physics by Paul Bellan. For more complete notes corresponding to the derivation online, please check out Single-Particle Motions.","category":"section"},{"location":"tutorial/#Choice-of-numerical-algorithms","page":"Tutorial","title":"Choice of numerical algorithms","text":"By default DifferentialEquations.jl applies Tsit5 to an ODE problem. If only OrdinaryDiffEq.jl is imported, then we need to explicitly select a solver. However, not all solvers are guaranteed to work. For example, the demo case of electron tracing in the magnetic bottle with strong magnetic field is tested to work only with fixed timestep algorithms like Euler and the Adams-Bashforth family.\n\nCurrently we recommend Vern9 as a starting point for adaptive timestepping, with additional fine tuning by changing reltol if needed. You can also try out the native implementation of the Boris method in TestParticle.jl, with a constraint of using a fixed time step.\n\nTake you some time to figure out which algorithm works for your problem!","category":"section"},{"location":"tutorial/#Unit-conversions","page":"Tutorial","title":"Unit conversions","text":"By default SI units are applied within the package. However, users can also define their own units by setting the particle mass and charge (2 constants) and providing the basic scales of magnetic field, length, time, or velocity (3 reference scales required; length, time and velocity are interchangable).\n\nIn the dimensionless natural unit system, we have the most number of ones which in turn gives the simplest form for computation. Check out the demos on unit conversions for more details.","category":"section"},{"location":"tutorial/#Tracing-backwards-in-time","page":"Tutorial","title":"Tracing backwards in time","text":"It is easy to trace a charged particle backwards in time. In a forward tracing problem, we set tspan = (t1, t2) where t1 < t2. In a backward tracing problem, we simply set t1 > t2, e.g. tspan = (0.0, -1.0). Note that tracing backwards in time is different from inversing the velocity because of the cross product in the Lorentz force. More specifically, the drift velocities will not change sign if one inverses velocity.","category":"section"},{"location":"tutorial/#Multiple-particles-tracing","page":"Tutorial","title":"Multiple particles tracing","text":"There are two ways to trace multiple particles simultaneously:\n\nExtracting the solution in a loop with varying initial conditions. See the example demo_ensemble.\nConstructing the Ensemble Simulations. One example can be found here. However, note that by default the ensemble type replicates the parameters for each solution, which is very memory inefficient for tracing in a numeric field. We need to set safetycopy=false to make the field as a reference in the parameter of each trajectory.\n\nThe Boris pusher follows a similar interface for multithreading.","category":"section"},{"location":"tutorial/#Guiding-center-drifts","page":"Tutorial","title":"Guiding center drifts","text":"By solving the trajectories of particles, we can calculate the actual guiding center orbits by following the definition. This is supported directly via get_gc. In theoretical treatments, all kinds of drifts have been derived with analytical formulas listed below (see trace_gc_drifts!). With additional ODEs for solving the drifts, we can separate the different effects or check the deviation of actual orbits from the low order analytical formulas.\n\nAn alternative approach is to solve the guiding center approximation equations. In TestParticle.jl, we provide tracing via solving the equations derived from Hamiltonian mechanics and their 1st order approximation.","category":"section"},{"location":"tutorial/#Summary-of-guiding-center-drifts","page":"Tutorial","title":"Summary of guiding center drifts","text":"General force:\n\nmathbfv_f = frac1qfracmathbfFtimesmathbfBB^2\n\nElectric field:\n\nmathbfv_E = fracmathbfEtimesmathbfBB^2\n\nGravitational field:\n\nmathbfv_g = fracmqfracmathbfgtimesmathbfBB^2\n\nNonuniform electric field:\n\nmathbfv_E = Big( 1+frac14r_L^2 nabla^2 Big)fracmathbfEtimesmathbfBB^2\n\nNonuniform magnetic field:\n\nGrad-B:\n\nbeginaligned\nmathbfv_nabla B = pm frac12v_perp r_LfracmathbfBtimesnabla BB^2 \n=fracmv_perp^22qB^3mathbfBtimesnabla B\nendaligned\n\nCurvature drift:\n\nbeginaligned\nmathbfv_c = fracmv_parallel^2qfracmathbfR_c timesmathbfBR_c^2 B^2 \n= fracmv_parallel^2qB^4mathbfBtimesleft mathbfBcdotnablamathbfB right \n= fracm v_parallel^2qB^3mathbfBtimesnabla Btext(current-free)\nendaligned\n\nCurved vacuum field:\n\nbeginaligned\nmathbfv_c + mathbfv_nabla B = fracmqBig( v_parallel^2 + frac12v_perp^2 Big) fracmathbfR_c timesmathbfBR_c^2 B^2 \n= fracmqfracmathbfBtimesnabla BB^3Big( v_parallel^2 + frac12v_perp^2 Big)\nendaligned\n\nPolarization drift:[2]\n\nmathbfv_p = pm frac1omega_c BfracdmathbfEdt\n\n[2]: In common test particle models, we assume static EM fields, so the polarization drift as well as adiabatic heating is not present. However, it is easily achieveable here in this package.","category":"section"},{"location":"tutorial/#Adiabatic-Invariants","page":"Tutorial","title":"Adiabatic Invariants","text":"See more thorough notes on the adiabatic invariants.","category":"section"},{"location":"tutorial/#Solution-Interpolations","page":"Tutorial","title":"Solution Interpolations","text":"All the tracing solutions come with an interpolation method to make them continuous. Depending on the order of the scheme, different orders of interpolations are applied.\n\nNote that if the scheme comes with an \"lazy\" interpolation (e.g. Vern family), you can either output the full solution (default) and interpolate\n\nsol = solve(prob, Vern9())\n\nor turn off the lazy interpolation and select part of the solution\n\nsol = solve(prob, Vern9(lazy=false), save_idxs=[1,2,3])\n\nThe interpolated solution would be wrong if lazy=true and save_idxs!=[1,2,3,4,5,6].","category":"section"},{"location":"tutorial/#Presentations","page":"Tutorial","title":"Presentations","text":"Please checkout:\n\nTestParticle.jl: A New Tool for An Old Problem\n基于开源工具链的测试粒子模型","category":"section"},{"location":"examples/advanced/demo_tokamak_coil/#demo_tokamak_coil","page":"Coil Tokamak","title":"Coil Tokamak","text":"(Image: Source code) (Image: compat) (Image: Author) (Image: Update time)\n\nThis example shows how to trace protons in a stationary magnetic field that corresponds to a Tokamak represented by a circle of coils. A excellent introduction video to Tokamak can be found here in Mandarin.\n\nusing TestParticle, OrdinaryDiffEqVerner, StaticArrays\nimport TestParticle as TP\nusing Statistics: mean\nusing Printf\nusing CairoMakie\n\n### Obtain field\n\n# Magnetic bottle parameters in SI units\nconst ICoil = 80.0 # current in the coil\nconst N = 15000 # number of windings\nconst IPlasma = 1e6 # current in the plasma\nconst a = 1.5 # radius of each coil\nconst b = 0.8 # radius of central region\n\ngetB(xu) = SVector{3}(TP.getB_tokamak_coil(xu[1], xu[2], xu[3], a, b, ICoil*N, IPlasma))\n\ngetE(xu) = SA[0.0, 0.0, 0.0]\n\n### Initialize particles\nm = TP.mᵢ\nq = TP.qᵢ\nc = TP.c\n\n# initial velocity, [m/s]\nv₀ = [-0.1, -0.15, 0.0] .* c\n# initial position, [m]\nr₀ = [2.3, 0.0, 0.0]\nstateinit = [r₀..., v₀...]\n\nparam = prepare(getE, getB; species = Proton)\ntspan = (0.0, 1e-6)\n\nprob = ODEProblem(trace!, stateinit, tspan, param)\n\n@printf \"Speed = %6.4f %s\\n\" √(v₀[1]^2+v₀[2]^2+v₀[3]^2)/c*100 \"% speed of light\"\n@printf \"Energy = %6.4f MeV\\n\" (1/√(1-(v₀[1]/c)^2-(v₀[2]/c)^2-(v₀[3]/c)^2)-1)*m*c^2/abs(q)/1e6\n\n# Default Tsit5() alone does not work in this case! You need to set a maximum\n# timestep to maintain stability, or choose a different algorithm as well.\n# The sample figure in the gallery is generated with AB3() and dt=2e-11.\nsol = solve(prob, Vern9(); dt = 2e-11)\n\n### Visualization\n\nf = Figure(fontsize = 18)\nax = Axis3(f[1, 1],\n   title = \"Particle trajectory in Tokamak\",\n   xlabel = \"x [m]\",\n   ylabel = \"y [m]\",\n   zlabel = \"z [m]\",\n   aspect = :data\n)\n\nlines!(ax, sol; idxs = (1, 2, 3), label = \"proton\")\n\n# Plot coils\nθ = range(0, 2π, length = 201)\ny = a * cos.(θ)\nz = a * sin.(θ)\nfor i in 0:17\n   ϕ = i*π/9\n   lines!(ax, y*sin(ϕ) .+ (a+b)*sin(ϕ), y*cos(ϕ) .+ (a+b)*cos(ϕ), z, color = (:red, 0.3))\nend\n\n# Plot Tokamak\nu = range(0, 2π, length = 100)\nv = range(0, 2π, length = 100)\n\nU = [y for _ in u, y in v]\nV = [x for x in u, _ in v]\n\nX = @. (a + b + (a - 0.05)*cos(U)) * cos(V)\nY = @. (a + b + (a - 0.05)*cos(U)) * sin(V)\nZ = @. (a - 0.05) * sin(U)\n\nwireframe!(ax, X, Y, Z, color = (:blue, 0.1), linewidth = 0.5, transparency = true)\n\n\n(Image: )\n\n\n\nThis page was generated using DemoCards.jl and Literate.jl.","category":"section"}]
}
